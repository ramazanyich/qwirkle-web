<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwirkle Online</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: Arial, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container { 
      max-width: 1200px; 
      margin: 0 auto; 
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    input, button {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      margin-bottom: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    button {
      cursor: pointer;
      color: white;
      border: none;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    button:hover:not(:disabled) { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-green { background: #27ae60; }
    .btn-blue { background: #3498db; }
    .btn-red { background: #e74c3c; }
    .btn-orange { background: #f39c12; }
    .tile {
      width: 50px;
      height: 50px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 2px solid #ccc;
      border-radius: 4px;
      cursor: grab;
      font-size: 32px;
      user-select: none;
    }
    .tile.selected { border: 3px solid #e74c3c; }
    .board-cell {
      width: 60px;
      height: 60px;
      border: 1px solid #bdc3c7;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .board-row { display: flex; }
    .board-container { 
      overflow-x: auto; 
      border: 2px solid #34495e; 
      border-radius: 5px; 
      background: #ecf0f1;
      margin: 20px 0;
    }
    .player-card {
      padding: 10px 15px;
      border-radius: 5px;
      margin: 5px;
      display: inline-block;
    }
    .hand-container { display: flex; gap: 10px; flex-wrap: wrap; margin: 20px 0; }
    h1, h2, h3 { color: #2c3e50; margin-bottom: 15px; }
    .game-id { 
      background: #ecf0f1; 
      padding: 15px; 
      border-radius: 5px; 
      margin-bottom: 20px;
      font-size: 18px;
    }
    .status-bar {
      padding: 10px;
      border-radius: 5px;
      text-align: center;
      color: white;
      margin-bottom: 20px;
      font-weight: bold;
    }
    .error-msg {
      background: #e74c3c;
      color: white;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="app">
      <div class="loading">
        <h1>üéÆ Qwirkle Online</h1>
        <p>Loading Firebase...</p>
        <p style="font-size: 14px; margin-top: 10px;">If this takes more than 5 seconds, check your internet connection.</p>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script>
    console.log('Script starting...');
    
    // Check if Firebase loaded
    if (typeof firebase === 'undefined') {
      document.getElementById('app').innerHTML = `
        <div class="error-msg">
          <h2>${t('firebaseError')}</h2>
          <p>${t('firebaseErrorDesc')}</p>
          <ul>
            <li>${t('poorConnection')}</li>
            <li>${t('firewall')}</li>
            <li>${t('browserSettings')}</li>
          </ul>
          <p style="margin-top: 10px;">${t('tryRefresh')}</p>
          <ul>
            <li>${t('refreshPage')}</li>
            <li>${t('disableAdblock')}</li>
            <li>${t('differentBrowser')}</li>
          </ul>
        </div>
      `;
      throw new Error('Firebase not loaded');
    }

    console.log('Firebase loaded successfully');

    const firebaseConfig = {
      apiKey: "AIzaSyBZvdbCflscZGDpV62zlycN6kEHOPnGjoE",
      authDomain: "qwirkle-5ebab.firebaseapp.com",
      databaseURL: "https://qwirkle-5ebab-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "qwirkle-5ebab",
      storageBucket: "qwirkle-5ebab.firebasestorage.app",
      messagingSenderId: "333453624833",
      appId: "1:333453624833:web:b679c5899f384818ce2200"
    };

    let db;
    try {
      firebase.initializeApp(firebaseConfig);
      db = firebase.database();
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Firebase initialization error:', error);
      document.getElementById('app').innerHTML = `
        <div class="error-msg">
          <h2>${t('firebaseInitError')}</h2>
          <p>${error.message}</p>
          <p>${t('refreshTryAgain')}</p>
        </div>
      `;
      throw error;
    }

    const SHAPES = ['circle', 'square', 'diamond', 'star', 'cross', 'clover'];
    const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
    const SHAPE_ICONS = { circle: '‚óè', square: '‚ñ†', diamond: '‚óÜ', star: '‚òÖ', cross: '‚úö', clover: '‚ô£' };
    const COLOR_MAP = { red: '#ff4081', orange: '#8B4513', yellow: '#f1c40f', green: '#2ecc71', blue: '#3498db', purple: '#9b59b6' };

    let state = {
      screen: 'menu',
      playerName: '',
      gameId: '',
      playerId: localStorage.getItem('qwirklePlayerId') || '',
      gameState: null,
      selectedTiles: [],
      pendingPlacements: [],
      draggedTile: null,
      tileToPlace: null,  // For click-to-place mode
      language: localStorage.getItem('qwirkleLanguage') || 'en'
    };

    const translations = {
      en: {
        title: 'Qwirkle Online',
        yourName: 'Your name',
        createGame: 'Create New Game',
        or: 'OR',
        gameId: 'Game ID',
        joinGame: 'Join Game',
        gameLobby: 'Game Lobby',
        shareId: 'Share this ID with friends!',
        players: 'Players',
        waitingHost: 'Waiting for host to start the game...',
        startGame: 'Start Game',
        bag: 'Bag',
        tiles: 'tiles',
        gameOver: 'Game Over!',
        winner: 'Winner',
        yourTurn: 'Your turn!',
        turn: "'s turn",
        clickToPlace: 'Click on the board to place your tile',
        tilesSelectedSwap: 'tiles selected for swap',
        clickTilePlace: 'Click a tile, then click where to place it',
        yourHand: 'Your Hand:',
        howToPlay: 'How to play:',
        placeOne: 'Place one tile:',
        placeOneDesc: 'Click a tile (green glow), then click on the board',
        placeMultiple: 'Place multiple tiles:',
        placeMultipleDesc: 'Drag tiles from your hand to the board',
        swapTiles: 'Swap tiles:',
        swapTilesDesc: 'Click 2+ tiles to select them (red border), then click "Swap"',
        removeTile: 'Remove placed tile:',
        removeTileDesc: 'Click on yellow tiles on the board',
        playButton: 'Play',
        tile: 'Tile',
        clearBoard: 'Clear Board',
        swap: 'Swap',
        enterName: 'Please enter your name!',
        enterNameAndId: 'Please enter your name and game ID!',
        gameNotFound: 'Game not found! Check the Game ID and try again.',
        gameStarted: 'Game already started!',
        gameFull: 'Game is full!',
        cannotSwap: 'Cannot swap - not enough tiles in bag',
        pts: 'pts',
        rules: 'Rules',
        rulesTitle: 'Qwirkle Rules',
        rulesClose: 'Close',
        rulesObjective: 'Objective:',
        rulesObjectiveText: 'Score the most points by creating lines of tiles that share a common attribute.',
        rulesTiles: 'Tiles:',
        rulesTilesText: '108 tiles with 6 shapes in 6 colors (3 of each combination).',
        rulesPlacement: 'Placement Rules:',
        rulesPlacement1: 'Tiles in a line must share either the same color OR the same shape (not both)',
        rulesPlacement2: 'No duplicate tiles in a line (same color AND same shape)',
        rulesPlacement3: 'Lines can have a maximum of 6 tiles',
        rulesPlacement4: 'New tiles must connect to existing tiles on the board',
        rulesScoring: 'Scoring:',
        rulesScoring1: 'Score 1 point per tile in each line you complete or extend',
        rulesScoring2: 'Complete a line of 6 tiles = QWIRKLE! = +6 bonus points (12 total)',
        rulesScoring3: 'If a tile creates multiple lines, you score for all of them',
        rulesTurns: 'Your Turn:',
        rulesTurns1: 'Place 1 or more tiles from your hand, OR',
        rulesTurns2: 'Swap any number of tiles (skip your turn)',
        rulesEnd: 'End of Game:',
        rulesEndText: 'Game ends when the bag is empty and one player plays their last tile. That player gets +6 bonus points. Highest score wins!',
        errorNoTiles: 'No tiles placed',
        errorSameRowCol: 'Tiles must be in same row or column',
        errorContinuous: 'Tiles must be continuous',
        errorMaxSix: 'Line cannot exceed 6 tiles',
        errorShareAttribute: 'Line must share color or shape',
        errorDuplicates: 'Duplicate tiles in line',
        errorConnect: 'Must connect to existing tiles',
        errorCreating: 'Error creating game',
        errorJoining: 'Error joining game',
        errorStarting: 'Error starting game',
        errorPlaying: 'Error playing tiles',
        errorSwapping: 'Error swapping tiles',
        firebaseError: 'Firebase Failed to Load',
        firebaseErrorDesc: 'The Firebase library couldn\'t load. This might be due to:',
        poorConnection: 'Poor internet connection',
        firewall: 'Firewall or ad-blocker blocking scripts',
        browserSettings: 'Browser security settings',
        tryRefresh: 'Try:',
        refreshPage: 'Refreshing the page',
        disableAdblock: 'Disabling ad-blockers',
        differentBrowser: 'Using a different browser',
        firebaseInitError: 'Firebase Initialization Error',
        refreshTryAgain: 'Please refresh the page and try again.',
        playerNotFound: 'Player data not found. Please refresh the page.'
      },
      ru: {
        title: 'Qwirkle –û–Ω–ª–∞–π–Ω',
        yourName: '–í–∞—à–µ –∏–º—è',
        createGame: '–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É',
        or: '–ò–õ–ò',
        gameId: 'ID –∏–≥—Ä—ã',
        joinGame: '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∏–≥—Ä–µ',
        gameLobby: '–õ–æ–±–±–∏ –∏–≥—Ä—ã',
        shareId: '–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–∏–º ID —Å –¥—Ä—É–∑—å—è–º–∏!',
        players: '–ò–≥—Ä–æ–∫–∏',
        waitingHost: '–û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã —Ö–æ—Å—Ç–æ–º...',
        startGame: '–ù–∞—á–∞—Ç—å –∏–≥—Ä—É',
        bag: '–ú–µ—à–æ–∫',
        tiles: '—Ñ–∏—à–µ–∫',
        gameOver: '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!',
        winner: '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å',
        yourTurn: '–í–∞—à —Ö–æ–¥!',
        turn: ' —Ö–æ–¥–∏—Ç',
        clickToPlace: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –¥–æ—Å–∫—É, —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ñ–∏—à–∫—É',
        tilesSelectedSwap: '—Ñ–∏—à–µ–∫ –≤—ã–±—Ä–∞–Ω–æ –¥–ª—è –æ–±–º–µ–Ω–∞',
        clickTilePlace: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ñ–∏—à–∫—É, –∑–∞—Ç–µ–º –∫—É–¥–∞ –µ—ë –ø–æ—Å—Ç–∞–≤–∏—Ç—å',
        yourHand: '–í–∞—à–∏ —Ñ–∏—à–∫–∏:',
        howToPlay: '–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:',
        placeOne: '–ü–æ—Å—Ç–∞–≤–∏—Ç—å –æ–¥–Ω—É —Ñ–∏—à–∫—É:',
        placeOneDesc: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ñ–∏—à–∫—É (–∑–µ–ª—ë–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ), –∑–∞—Ç–µ–º –Ω–∞ –¥–æ—Å–∫—É',
        placeMultiple: '–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∏—à–µ–∫:',
        placeMultipleDesc: '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∏—à–∫–∏ –∏–∑ —Ä—É–∫–∏ –Ω–∞ –¥–æ—Å–∫—É',
        swapTiles: '–û–±–º–µ–Ω—è—Ç—å —Ñ–∏—à–∫–∏:',
        swapTilesDesc: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ 2+ —Ñ–∏—à–∫–∏ (–∫—Ä–∞—Å–Ω–∞—è —Ä–∞–º–∫–∞), –∑–∞—Ç–µ–º "–û–±–º–µ–Ω—è—Ç—å"',
        removeTile: '–£–±—Ä–∞—Ç—å –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—É—é —Ñ–∏—à–∫—É:',
        removeTileDesc: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∂—ë–ª—Ç—É—é —Ñ–∏—à–∫—É –Ω–∞ –¥–æ—Å–∫–µ',
        playButton: '–°—ã–≥—Ä–∞—Ç—å',
        tile: '—Ñ–∏—à–∫—É',
        clearBoard: '–û—á–∏—Å—Ç–∏—Ç—å –¥–æ—Å–∫—É',
        swap: '–û–±–º–µ–Ω—è—Ç—å',
        enterName: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è!',
        enterNameAndId: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ ID –∏–≥—Ä—ã!',
        gameNotFound: '–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID –∏–≥—Ä—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.',
        gameStarted: '–ò–≥—Ä–∞ —É–∂–µ –Ω–∞—á–∞–ª–∞—Å—å!',
        gameFull: '–ò–≥—Ä–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞!',
        cannotSwap: '–ù–µ–ª—å–∑—è –æ–±–º–µ–Ω—è—Ç—å - –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ñ–∏—à–µ–∫ –≤ –º–µ—à–∫–µ',
        pts: '–æ—á–∫.',
        rules: '–ü—Ä–∞–≤–∏–ª–∞',
        rulesTitle: '–ü—Ä–∞–≤–∏–ª–∞ Qwirkle',
        rulesClose: '–ó–∞–∫—Ä—ã—Ç—å',
        rulesObjective: '–¶–µ–ª—å:',
        rulesObjectiveText: '–ù–∞–±—Ä–∞—Ç—å –º–∞–∫—Å–∏–º—É–º –æ—á–∫–æ–≤, —Å–æ–∑–¥–∞–≤–∞—è –ª–∏–Ω–∏–∏ —Ñ–∏—à–µ–∫ —Å –æ–±—â–∏–º–∏ –ø—Ä–∏–∑–Ω–∞–∫–∞–º–∏.',
        rulesTiles: '–§–∏—à–∫–∏:',
        rulesTilesText: '108 —Ñ–∏—à–µ–∫ —Å 6 —Ñ–æ—Ä–º–∞–º–∏ –≤ 6 —Ü–≤–µ—Ç–∞—Ö (–ø–æ 3 –∫–∞–∂–¥–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏).',
        rulesPlacement: '–ü—Ä–∞–≤–∏–ª–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è:',
        rulesPlacement1: '–§–∏—à–∫–∏ –≤ –ª–∏–Ω–∏–∏ –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ü–≤–µ—Ç –ò–õ–ò –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —Ñ–æ—Ä–º—É (–Ω–µ –æ–±–∞)',
        rulesPlacement2: '–ù–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –≤ –ª–∏–Ω–∏–∏ (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ü–≤–µ—Ç –ò —Ñ–æ—Ä–º–∞)',
        rulesPlacement3: '–õ–∏–Ω–∏–∏ –º–æ–≥—É—Ç –∏–º–µ—Ç—å –º–∞–∫—Å–∏–º—É–º 6 —Ñ–∏—à–µ–∫',
        rulesPlacement4: '–ù–æ–≤—ã–µ —Ñ–∏—à–∫–∏ –¥–æ–ª–∂–Ω—ã —Å–æ–µ–¥–∏–Ω—è—Ç—å—Å—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –Ω–∞ –¥–æ—Å–∫–µ',
        rulesScoring: '–ü–æ–¥—Å—á—ë—Ç –æ—á–∫–æ–≤:',
        rulesScoring1: '1 –æ—á–∫–æ –∑–∞ –∫–∞–∂–¥—É—é —Ñ–∏—à–∫—É –≤ –ª–∏–Ω–∏–∏, –∫–æ—Ç–æ—Ä—É—é –≤—ã —Å–æ–∑–¥–∞–ª–∏ –∏–ª–∏ –¥–æ–ø–æ–ª–Ω–∏–ª–∏',
        rulesScoring2: '–õ–∏–Ω–∏—è –∏–∑ 6 —Ñ–∏—à–µ–∫ = QWIRKLE! = +6 –±–æ–Ω—É—Å–Ω—ã—Ö –æ—á–∫–æ–≤ (12 –≤—Å–µ–≥–æ)',
        rulesScoring3: '–ï—Å–ª–∏ —Ñ–∏—à–∫–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–∏–Ω–∏–π, –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –æ—á–∫–∏ –∑–∞ –≤—Å–µ',
        rulesTurns: '–í–∞—à —Ö–æ–¥:',
        rulesTurns1: '–ü–æ—Å—Ç–∞–≤—å—Ç–µ 1 –∏–ª–∏ –±–æ–ª—å—à–µ —Ñ–∏—à–µ–∫ –∏–∑ —Ä—É–∫–∏, –ò–õ–ò',
        rulesTurns2: '–û–±–º–µ–Ω—è–π—Ç–µ –ª—é–±–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∏—à–µ–∫ (–ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç–µ —Ö–æ–¥)',
        rulesEnd: '–ö–æ–Ω–µ—Ü –∏–≥—Ä—ã:',
        rulesEndText: '–ò–≥—Ä–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –º–µ—à–æ–∫ –ø—É—Å—Ç –∏ –∏–≥—Ä–æ–∫ –≤—ã—Å—Ç–∞–≤–∏–ª –ø–æ—Å–ª–µ–¥–Ω—é—é —Ñ–∏—à–∫—É. –≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–ª—É—á–∞–µ—Ç +6 –±–æ–Ω—É—Å–Ω—ã—Ö –æ—á–∫–æ–≤. –ü–æ–±–µ–∂–¥–∞–µ—Ç –∏–≥—Ä–æ–∫ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º —Å—á—ë—Ç–æ–º!',
        errorNoTiles: '–§–∏—à–∫–∏ –Ω–µ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω—ã',
        errorSameRowCol: '–§–∏—à–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –æ–¥–Ω–æ–º —Ä—è–¥—É –∏–ª–∏ —Å—Ç–æ–ª–±—Ü–µ',
        errorContinuous: '–§–∏—à–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–º–∏',
        errorMaxSix: '–õ–∏–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å 6 —Ñ–∏—à–µ–∫',
        errorShareAttribute: '–õ–∏–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –æ–±—â–∏–π —Ü–≤–µ—Ç –∏–ª–∏ —Ñ–æ—Ä–º—É',
        errorDuplicates: '–î—É–±–ª–∏–∫–∞—Ç—ã —Ñ–∏—à–µ–∫ –≤ –ª–∏–Ω–∏–∏',
        errorConnect: '–î–æ–ª–∂–Ω—ã —Å–æ–µ–¥–∏–Ω—è—Ç—å—Å—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ —Ñ–∏—à–∫–∞–º–∏',
        errorCreating: '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–≥—Ä—ã',
        errorJoining: '–û—à–∏–±–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ –∏–≥—Ä–µ',
        errorStarting: '–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã',
        errorPlaying: '–û—à–∏–±–∫–∞ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ñ–∏—à–µ–∫',
        errorSwapping: '–û—à–∏–±–∫–∞ –æ–±–º–µ–Ω–∞ —Ñ–∏—à–µ–∫',
        firebaseError: '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Firebase',
        firebaseErrorDesc: '–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ Firebase –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å. –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑-–∑–∞:',
        poorConnection: '–ü–ª–æ—Ö–æ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è',
        firewall: '–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Å–∫—Ä–∏–ø—Ç–æ–≤ —Ñ–∞–π—Ä–≤–æ–ª–æ–º –∏–ª–∏ –±–ª–æ–∫–∏—Ä–æ–≤—â–∏–∫–æ–º —Ä–µ–∫–ª–∞–º—ã',
        browserSettings: '–ù–∞—Å—Ç—Ä–æ–µ–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –±—Ä–∞—É–∑–µ—Ä–∞',
        tryRefresh: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:',
        refreshPage: '–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É',
        disableAdblock: '–û—Ç–∫–ª—é—á–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤—â–∏–∫–∏ —Ä–µ–∫–ª–∞–º—ã',
        differentBrowser: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π –±—Ä–∞—É–∑–µ—Ä',
        firebaseInitError: '–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Firebase',
        refreshTryAgain: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.',
        playerNotFound: '–î–∞–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.'
      }
    };

    function t(key) {
      return translations[state.language][key] || key;
    }

    function toggleLanguage() {
      state.language = state.language === 'en' ? 'ru' : 'en';
      localStorage.setItem('qwirkleLanguage', state.language);
      render();
    }

    function showRules() {
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 20px;';
      
      overlay.innerHTML = `
        <div style="background: white; border-radius: 10px; padding: 30px; max-width: 600px; max-height: 90vh; overflow-y: auto;">
          <h2 style="margin-bottom: 20px; color: #2c3e50;">${t('rulesTitle')}</h2>
          
          <h3 style="color: #27ae60; margin-top: 15px;">${t('rulesObjective')}</h3>
          <p>${t('rulesObjectiveText')}</p>
          
          <h3 style="color: #27ae60; margin-top: 15px;">${t('rulesTiles')}</h3>
          <p>${t('rulesTilesText')}</p>
          
          <h3 style="color: #27ae60; margin-top: 15px;">${t('rulesPlacement')}</h3>
          <ul style="margin-left: 20px;">
            <li>${t('rulesPlacement1')}</li>
            <li>${t('rulesPlacement2')}</li>
            <li>${t('rulesPlacement3')}</li>
            <li>${t('rulesPlacement4')}</li>
          </ul>
          
          <h3 style="color: #27ae60; margin-top: 15px;">${t('rulesScoring')}</h3>
          <ul style="margin-left: 20px;">
            <li>${t('rulesScoring1')}</li>
            <li>${t('rulesScoring2')}</li>
            <li>${t('rulesScoring3')}</li>
          </ul>
          
          <h3 style="color: #27ae60; margin-top: 15px;">${t('rulesTurns')}</h3>
          <ul style="margin-left: 20px;">
            <li>${t('rulesTurns1')}</li>
            <li>${t('rulesTurns2')}</li>
          </ul>
          
          <h3 style="color: #27ae60; margin-top: 15px;">${t('rulesEnd')}</h3>
          <p>${t('rulesEndText')}</p>
          
          <button class="btn-blue" id="closeRules" style="margin-top: 20px;">${t('rulesClose')}</button>
        </div>
      `;
      
      document.body.appendChild(overlay);
      document.getElementById('closeRules').onclick = () => overlay.remove();
      overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
    }

    function debugCrossTiles() {
      let report = 'CLOVER TILES DEBUG:\n\n';
      
      // Check board
      if (state.gameState && state.gameState.board) {
        let cloverCount = 0;
        Object.entries(state.gameState.board).forEach(([pos, tile]) => {
          if (tile.shape === 'clover') {
            cloverCount++;
            const expectedColor = COLOR_MAP[tile.color];
            report += `Board ${pos}:\n  Color: ${tile.color}\n  Expected: ${expectedColor}\n\n`;
          }
        });
        report += `Total clovers on board: ${cloverCount}\n\n`;
      }
      
      // Check hand
      if (state.gameState && state.gameState.players && state.gameState.players[state.playerId]) {
        const hand = state.gameState.players[state.playerId].hand;
        let handCloverCount = 0;
        hand.forEach(tile => {
          if (tile.shape === 'clover') {
            handCloverCount++;
            const expectedColor = COLOR_MAP[tile.color];
            report += `Hand tile:\n  Color: ${tile.color}\n  Expected: ${expectedColor}\n\n`;
          }
        });
        report += `Total clovers in hand: ${handCloverCount}`;
      }
      
      alert(report);
    }

    window.debugCrossTiles = debugCrossTiles;

    function createDeck() {
      const deck = [];
      SHAPES.forEach(shape => {
        COLORS.forEach(color => {
          for (let i = 0; i < 3; i++) {
            deck.push({ shape, color, id: `${shape}-${color}-${i}` });
          }
        });
      });
      return deck.sort(() => Math.random() - 0.5);
    }

    function renderTile(tile, options = {}) {
      // Safety check: ensure tile has required properties
      if (!tile || !tile.shape || !tile.color) {
        console.error('Invalid tile - shape:', tile?.shape, 'color:', tile?.color);
        return document.createElement('div');
      }
      
      const div = document.createElement('div');
      div.className = 'tile' + (options.selected ? ' selected' : '');
      div.draggable = options.draggable || false;
      
      // Ensure color is valid and exists in COLOR_MAP
      const tileColor = COLOR_MAP[tile.color];
      if (!tileColor) {
        console.error('Unknown tile color:', tile.color, 'Available:', Object.keys(COLOR_MAP));
        div.style.color = '#cccccc'; // Gray fallback
      } else {
        div.style.color = tileColor;
      }
      
      // Ensure shape icon exists
      const shapeIcon = SHAPE_ICONS[tile.shape];
      if (!shapeIcon) {
        console.error('Unknown tile shape:', tile.shape);
        div.textContent = '?';
      } else {
        div.textContent = shapeIcon;
      }
      
      if (options.onClick) div.onclick = options.onClick;
      if (options.onDragStart) div.ondragstart = options.onDragStart;
      return div;
    }

    async function createGame() {
      console.log('Create game clicked, playerName:', state.playerName);
      
      if (!state.playerName.trim()) {
        alert(t('enterName'));
        return;
      }
      
      try {
        const newPlayerId = `player_${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
        state.playerId = newPlayerId;
        localStorage.setItem('qwirklePlayerId', newPlayerId);

        const deck = createDeck();
        const player1Hand = deck.splice(0, 6);
        
        console.log('Creating new game in Firebase...');
        const newGameRef = db.ref('games').push();
        const newGameId = newGameRef.key;
        
        await newGameRef.set({
          players: { [newPlayerId]: { name: state.playerName, hand: player1Hand, score: 0, order: 0 } },
          deck: deck,
          board: {},
          currentPlayerIndex: 0,
          playerOrder: [newPlayerId],
          status: 'waiting',
          createdAt: Date.now()
        });

        console.log('Game created successfully with ID:', newGameId);
        state.gameId = newGameId;
        state.screen = 'lobby';
        render();
        listenToGame();
      } catch (error) {
        console.error('Error creating game:', error);
        alert(t('errorCreating') + ': ' + error.message);
      }
    }

    async function joinGame() {
      console.log('Join game clicked');
      
      if (!state.playerName.trim() || !state.gameId.trim()) {
        alert(t('enterNameAndId'));
        return;
      }
      
      try {
        const newPlayerId = `player_${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
        state.playerId = newPlayerId;
        localStorage.setItem('qwirklePlayerId', newPlayerId);

        console.log('Fetching game:', state.gameId);
        const snapshot = await db.ref(`games/${state.gameId}`).once('value');
        const game = snapshot.val();
        
        if (!game) { 
          alert(t('gameNotFound')); 
          return; 
        }
        if (game.status !== 'waiting') { 
          alert(t('gameStarted')); 
          return; 
        }
        if (Object.keys(game.players).length >= 4) { 
          alert(t('gameFull')); 
          return; 
        }

        const deck = [...game.deck];
        const hand = deck.splice(0, 6);
        const playerCount = Object.keys(game.players).length;
        
        console.log('Joining game...');
        await db.ref(`games/${state.gameId}`).update({
          [`players/${newPlayerId}`]: { name: state.playerName, hand, score: 0, order: playerCount },
          deck,
          playerOrder: [...game.playerOrder, newPlayerId]
        });

        console.log('Joined successfully');
        state.screen = 'lobby';
        render();
        listenToGame();
      } catch (error) {
        console.error('Error joining game:', error);
        alert(t('errorJoining') + ': ' + error.message);
      }
    }

    function listenToGame() {
      console.log('Starting to listen to game updates');
      db.ref(`games/${state.gameId}`).on('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          console.log('Game state updated, status:', data.status);
          
          // DEBUG: Log board data received from Firebase
          if (data.board) {
            console.log('Board data received:', data.board);
            Object.entries(data.board).forEach(([pos, tile]) => {
              if (tile.shape === 'cross') {
                console.log('Cross tile at', pos, ':', JSON.stringify(tile));
              }
            });
          }
          
          state.gameState = data;
          
          // Automatically transition to game screen when status changes to playing
          if (data.status === 'playing' && state.screen !== 'game') {
            state.screen = 'game';
          }
          
          render();
        }
      });
    }

    async function startGame() {
      try {
        console.log('Starting game...');
        await db.ref(`games/${state.gameId}`).update({ status: 'playing' });
        console.log('Game status updated to playing');
        state.screen = 'game';
        // Don't render immediately - let Firebase listener update the state first
        // render() will be called automatically by the listener
      } catch (error) {
        console.error('Error starting game:', error);
        alert(t('errorStarting') + ': ' + error.message);
      }
    }

    function validatePlacement(placements, board) {
      if (placements.length === 0) return { valid: false, reason: t('errorNoTiles') };

      // Ensure board is an object, even if it's undefined/null
      board = board || {};
      
      const newBoard = { ...board };
      placements.forEach(p => { newBoard[`${p.row},${p.col}`] = p.tile; });

      const rows = placements.map(p => p.row);
      const cols = placements.map(p => p.col);
      const sameRow = rows.every(r => r === rows[0]);
      const sameCol = cols.every(c => c === cols[0]);

      if (!sameRow && !sameCol) return { valid: false, reason: t('errorSameRowCol') };

      if (sameRow) {
        const sortedCols = [...cols].sort((a, b) => a - b);
        for (let i = 0; i < sortedCols.length - 1; i++) {
          for (let c = sortedCols[i] + 1; c < sortedCols[i + 1]; c++) {
            if (!newBoard[`${rows[0]},${c}`]) return { valid: false, reason: t('errorContinuous') };
          }
        }
      } else {
        const sortedRows = [...rows].sort((a, b) => a - b);
        for (let i = 0; i < sortedRows.length - 1; i++) {
          for (let r = sortedRows[i] + 1; r < sortedRows[i + 1]; r++) {
            if (!newBoard[`${r},${cols[0]}`]) return { valid: false, reason: t('errorContinuous') };
          }
        }
      }

      const linesToCheck = new Set();
      placements.forEach(p => {
        linesToCheck.add(`row-${p.row}`);
        linesToCheck.add(`col-${p.col}`);
      });

      for (const line of linesToCheck) {
        const [type, pos] = line.split('-');
        const position = parseInt(pos);
        const tiles = [];
        
        if (type === 'row') {
          for (let c = -50; c <= 50; c++) {
            const tile = newBoard[`${position},${c}`];
            if (tile) tiles.push(tile);
            else if (tiles.length > 0) break;
          }
        } else {
          for (let r = -50; r <= 50; r++) {
            const tile = newBoard[`${r},${position}`];
            if (tile) tiles.push(tile);
            else if (tiles.length > 0) break;
          }
        }

        if (tiles.length > 6) return { valid: false, reason: t('errorMaxSix') };

        if (tiles.length > 1) {
          const colors = tiles.map(t => t.color);
          const shapes = tiles.map(t => t.shape);
          const uniqueColors = new Set(colors);
          const uniqueShapes = new Set(shapes);

          const allSameColor = uniqueColors.size === 1;
          const allSameShape = uniqueShapes.size === 1;

          if (!allSameColor && !allSameShape) return { valid: false, reason: t('errorShareAttribute') };
          if (allSameColor && uniqueShapes.size !== tiles.length) return { valid: false, reason: t('errorDuplicates') };
          if (allSameShape && uniqueColors.size !== tiles.length) return { valid: false, reason: t('errorDuplicates') };
        }
      }

      if (Object.keys(board).length === 0) return { valid: true, score: calculateScore(placements, newBoard) };

      let connected = false;
      for (const p of placements) {
        const adjacent = [
          newBoard[`${p.row - 1},${p.col}`],
          newBoard[`${p.row + 1},${p.col}`],
          newBoard[`${p.row},${p.col - 1}`],
          newBoard[`${p.row},${p.col + 1}`]
        ];
        if (adjacent.some(t => t && !placements.find(pl => pl.tile.id === t.id))) {
          connected = true;
          break;
        }
      }

      if (!connected) return { valid: false, reason: t('errorConnect') };
      return { valid: true, score: calculateScore(placements, newBoard) };
    }

    function calculateScore(placements, board) {
      // Ensure board is an object
      board = board || {};
      
      let totalScore = 0;
      const scoredLines = new Set();

      placements.forEach(p => {
        const rowKey = `row-${p.row}`;
        if (!scoredLines.has(rowKey)) {
          let rowTiles = [];
          for (let c = -50; c <= 50; c++) {
            const tile = board[`${p.row},${c}`];
            if (tile) rowTiles.push(tile);
            else if (rowTiles.length > 0) break;
          }
          if (rowTiles.length > 1) {
            let score = rowTiles.length;
            if (rowTiles.length === 6) score += 6;
            totalScore += score;
            scoredLines.add(rowKey);
          }
        }

        const colKey = `col-${p.col}`;
        if (!scoredLines.has(colKey)) {
          let colTiles = [];
          for (let r = -50; r <= 50; r++) {
            const tile = board[`${r},${p.col}`];
            if (tile) colTiles.push(tile);
            else if (colTiles.length > 0) break;
          }
          if (colTiles.length > 1) {
            let score = colTiles.length;
            if (colTiles.length === 6) score += 6;
            totalScore += score;
            scoredLines.add(colKey);
          }
        }
      });

      if (totalScore === 0 && placements.length > 0) totalScore = placements.length;
      return totalScore;
    }

    async function playTiles() {
      if (state.pendingPlacements.length === 0) return;

      const validation = validatePlacement(state.pendingPlacements, state.gameState.board);
      if (!validation.valid) { alert(validation.reason); return; }

      const newBoard = { ...state.gameState.board };
      state.pendingPlacements.forEach(p => { newBoard[`${p.row},${p.col}`] = p.tile; });

      const currentPlayer = state.gameState.players[state.playerId];
      const newHand = currentPlayer.hand.filter(t => !state.pendingPlacements.find(p => p.tile.id === t.id));

      let newDeck = [...state.gameState.deck];
      const tilesToDraw = Math.min(state.pendingPlacements.length, newDeck.length);
      const drawnTiles = newDeck.splice(0, tilesToDraw);
      newHand.push(...drawnTiles);

      const newScore = currentPlayer.score + validation.score;
      const nextPlayerIndex = (state.gameState.currentPlayerIndex + 1) % state.gameState.playerOrder.length;

      const updates = {
        board: newBoard,
        deck: newDeck,
        [`players/${state.playerId}/hand`]: newHand,
        [`players/${state.playerId}/score`]: newScore,
        currentPlayerIndex: nextPlayerIndex
      };

      if (newDeck.length === 0 && newHand.length === 0) {
        updates[`players/${state.playerId}/score`] = newScore + 6;
        updates.status = 'finished';
      }

      await db.ref(`games/${state.gameId}`).update(updates);
      state.pendingPlacements = [];
      state.selectedTiles = [];
      render();
    }

    async function swapTiles() {
      if (state.selectedTiles.length === 0 || state.gameState.deck.length < state.selectedTiles.length) {
        alert(t('cannotSwap'));
        return;
      }

      const currentPlayer = state.gameState.players[state.playerId];
      const newHand = currentPlayer.hand.filter(t => !state.selectedTiles.find(s => s.id === t.id));

      let newDeck = [...state.gameState.deck];
      const drawn = newDeck.splice(0, state.selectedTiles.length);
      newHand.push(...drawn);
      newDeck.push(...state.selectedTiles);
      newDeck.sort(() => Math.random() - 0.5);

      const nextPlayerIndex = (state.gameState.currentPlayerIndex + 1) % state.gameState.playerOrder.length;

      await db.ref(`games/${state.gameId}`).update({
        deck: newDeck,
        [`players/${state.playerId}/hand`]: newHand,
        currentPlayerIndex: nextPlayerIndex
      });

      state.selectedTiles = [];
      render();
    }

    function render() {
      console.log('Rendering screen:', state.screen);
      const app = document.getElementById('app');
      app.innerHTML = '';

      if (state.screen === 'menu') {
        app.innerHTML = `
          <div style="text-align: right; margin-bottom: 20px;">
            <button onclick="toggleLanguage()" style="width: auto; padding: 8px 16px; background: #95a5a6; cursor: pointer;">
              ${state.language === 'en' ? 'üá∑üá∫ –†—É—Å—Å–∫–∏–π' : 'üá¨üáß English'}
            </button>
          </div>
          <h1 style="text-align: center;">${t('title')}</h1>
          <div style="max-width: 500px; margin: 0 auto;">
            <input type="text" id="playerName" placeholder="${t('yourName')}" value="${state.playerName}">
            <button class="btn-green" id="createBtn">${t('createGame')}</button>
            <div style="margin: 20px 0; text-align: center; color: #7f8c8d;">${t('or')}</div>
            <input type="text" id="gameIdInput" placeholder="${t('gameId')}" value="${state.gameId}">
            <button class="btn-blue" id="joinBtn">${t('joinGame')}</button>
            <button class="btn-gray" id="rulesBtn" style="margin-top: 20px;">${t('rules')}</button>
          </div>
        `;
        
        const nameInput = document.getElementById('playerName');
        const gameInput = document.getElementById('gameIdInput');
        const createBtn = document.getElementById('createBtn');
        const joinBtn = document.getElementById('joinBtn');
        const rulesBtn = document.getElementById('rulesBtn');
        
        window.toggleLanguage = toggleLanguage;
        
        nameInput.oninput = (e) => {
          state.playerName = e.target.value;
          console.log('Player name updated:', state.playerName);
        };
        gameInput.oninput = (e) => {
          state.gameId = e.target.value;
          console.log('Game ID updated:', state.gameId);
        };
        createBtn.onclick = () => {
          console.log('Create button clicked');
          createGame();
        };
        joinBtn.onclick = () => {
          console.log('Join button clicked');
          joinGame();
        };
        rulesBtn.onclick = () => {
          showRules();
        };
        
        console.log('Menu rendered, buttons attached');
      }

      else if (state.screen === 'lobby' && state.gameState) {
        const isHost = state.gameState.playerOrder[0] === state.playerId;
        const playerCount = Object.keys(state.gameState.players).length;

        app.innerHTML = `
          <h1 style="text-align: center;">${t('gameLobby')}</h1>
          <div class="game-id">
            <strong>${t('gameId')}:</strong> <span style="font-size: 24px; color: #2c3e50;">${state.gameId}</span>
            <p style="font-size: 14px; color: #7f8c8d; margin-top: 10px;">${t('shareId')}</p>
          </div>
          <h3>${t('players')} (${playerCount}/4):</h3>
          <div id="playerList"></div>
          ${isHost && playerCount >= 2 ? `<button class="btn-green" id="startBtn">${t('startGame')}</button>` : ''}
          ${!isHost ? `<p style="text-align: center; color: #7f8c8d; margin-top: 20px;">${t('waitingHost')}</p>` : ''}
        `;

        const playerList = document.getElementById('playerList');
        Object.entries(state.gameState.players).forEach(([id, player]) => {
          const div = document.createElement('div');
          div.className = 'player-card';
          div.style.background = '#ecf0f1';
          div.textContent = `${player.name}${id === state.playerId ? ' (You)' : ''}${id === state.gameState.playerOrder[0] ? ' üëë' : ''}`;
          playerList.appendChild(div);
        });

        if (isHost && playerCount >= 2) {
          document.getElementById('startBtn').onclick = startGame;
        }
      }

      else if (state.screen === 'game' && state.gameState) {
        console.log('Rendering game screen');
        const currentPlayer = state.gameState.players[state.playerId];
        
        if (!currentPlayer) {
          console.error('Current player not found! PlayerID:', state.playerId);
          console.error('Available players:', Object.keys(state.gameState.players));
          app.innerHTML = `<div class="error-msg"><h2>${t('firebaseInitError')}</h2><p>${t('playerNotFound')}</p></div>`;
          return;
        }
        
        console.log('Current player found:', currentPlayer.name);
        
        const isMyTurn = state.gameState.playerOrder[state.gameState.currentPlayerIndex] === state.playerId;
        const currentTurnPlayer = state.gameState.players[state.gameState.playerOrder[state.gameState.currentPlayerIndex]];

        let minRow = -2, maxRow = 2, minCol = -2, maxCol = 2;
        const board = state.gameState.board || {};
        
        if (Object.keys(board).length > 0) {
          minRow = 0; maxRow = 0; minCol = 0; maxCol = 0;
          Object.keys(board).forEach(key => {
            const [r, c] = key.split(',').map(Number);
            minRow = Math.min(minRow, r);
            maxRow = Math.max(maxRow, r);
            minCol = Math.min(minCol, c);
            maxCol = Math.max(maxCol, c);
          });
          minRow -= 2; maxRow += 2; minCol -= 2; maxCol += 2;
        }
        
        console.log('Board dimensions:', minRow, maxRow, minCol, maxCol);

        app.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
            <h2>Qwirkle Game</h2>
            <div><strong>Game ID:</strong> ${state.gameId} | <strong>Bag:</strong> ${state.gameState.deck.length} tiles</div>
          </div>
          <div id="scores" style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;"></div>
          ${state.gameState.status === 'finished' ? `
            <div style="background: #f39c12; padding: 15px; border-radius: 5px; margin-bottom: 20px; text-align: center; color: white; font-size: 18px;">
              <strong>Game Over!</strong> Winner: ${Object.values(state.gameState.players).sort((a, b) => b.score - a.score)[0].name}
            </div>
          ` : ''}
          ${isMyTurn && state.gameState.status === 'playing' ? `
            <div class="status-bar" style="background: ${isMyTurn ? '#27ae60' : '#95a5a6'};">
              ${isMyTurn ? (state.tileToPlace ? "üìç Click on the board to place your tile" : state.selectedTiles.length > 0 ? `üîÑ ${state.selectedTiles.length} tiles selected for swap` : "üëÜ Click a tile, then click where to place it") : `${currentTurnPlayer.name}'s turn`}
            </div>
          ` : state.gameState.status === 'playing' ? `
            <div class="status-bar" style="background: #95a5a6;">
              ${currentTurnPlayer.name}'s turn
            </div>
          ` : ''}
          <div class="board-container">
            <div style="display: inline-block; padding: 20px;" id="board"></div>
          </div>
          <h3>Your Hand:</h3>
          <div class="hand-container" id="hand"></div>
          ${isMyTurn && state.gameState.status === 'playing' ? `
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px;">
              <button class="btn-green" id="playBtn" ${state.pendingPlacements.length === 0 ? 'disabled' : ''}>Play Tiles</button>
              <button class="btn-red" id="cancelBtn" ${state.pendingPlacements.length === 0 ? 'disabled' : ''}>Cancel</button>
              <button class="btn-orange" id="swapBtn" ${state.selectedTiles.length === 0 || state.gameState.deck.length < state.selectedTiles.length ? 'disabled' : ''}>Swap Selected (${state.selectedTiles.length})</button>
            </div>
          ` : ''}
        `;

        console.log('HTML structure created, populating scores...');
        const scoresDiv = document.getElementById('scores');
        if (!scoresDiv) {
          console.error('Scores div not found!');
          return;
        }
        state.gameState.playerOrder.forEach((pid, idx) => {
          const p = state.gameState.players[pid];
          const isCurrent = idx === state.gameState.currentPlayerIndex;
          const card = document.createElement('div');
          card.className = 'player-card';
          card.style.background = isCurrent ? '#3498db' : '#ecf0f1';
          card.style.color = isCurrent ? 'white' : 'black';
          if (pid === state.playerId) card.style.border = '3px solid #27ae60';
          card.textContent = `${p.name}: ${p.score} ${t('pts')}${isCurrent ? ' üéØ' : ''}`;
          scoresDiv.appendChild(card);
        });
        console.log('Scores populated');

        console.log('Creating board...');
        const boardDiv = document.getElementById('board');
        if (!boardDiv) {
          console.error('Board div not found!');
          return;
        }
        
        // Debug: Log board state
        console.log('Rendering board with tiles:', Object.keys(board).length);
        if (Object.keys(board).length > 0) {
          console.log('Sample board tile:', Object.values(board)[0]);
        }
        
        for (let row = minRow; row <= maxRow; row++) {
          const rowDiv = document.createElement('div');
          rowDiv.className = 'board-row';
          for (let col = minCol; col <= maxCol; col++) {
            const key = `${row},${col}`;
            const tile = board[key];
            const pending = state.pendingPlacements.find(p => p.row === row && p.col === col);
            
            const cell = document.createElement('div');
            cell.className = 'board-cell';
            cell.style.background = pending ? '#ffffcc' : tile ? 'white' : '#f8f9fa';
            
            cell.ondragover = (e) => e.preventDefault();
            cell.ondrop = (e) => {
              e.preventDefault();
              if (state.draggedTile && isMyTurn && !tile && !pending) {
                state.pendingPlacements.push({ row, col, tile: state.draggedTile });
                render();
              }
            };

            if (tile) {
              cell.appendChild(renderTile(tile));
            }
            if (pending) {
              const pendingTile = renderTile(pending.tile, {
                onClick: () => {
                  state.pendingPlacements = state.pendingPlacements.filter(p => p !== pending);
                  render();
                }
              });
              pendingTile.style.opacity = '0.8';
              cell.appendChild(pendingTile);
            }
            
            rowDiv.appendChild(cell);
          }
          boardDiv.appendChild(rowDiv);
        }
        console.log('Board created');

        console.log('Creating hand with', currentPlayer.hand ? currentPlayer.hand.length : 0, 'tiles');
        const handDiv = document.getElementById('hand');
        if (!handDiv) {
          console.error('Hand div not found!');
          return;
        }
        if (currentPlayer.hand && Array.isArray(currentPlayer.hand)) {
          currentPlayer.hand.forEach(tile => {
            const isSelected = state.selectedTiles.find(t => t.id === tile.id);
            const tileEl = renderTile(tile, {
              draggable: true,
              selected: isSelected,
              onDragStart: () => { state.draggedTile = tile; },
              onClick: () => {
                if (isSelected) {
                  state.selectedTiles = state.selectedTiles.filter(t => t.id !== tile.id);
                } else {
                  state.selectedTiles.push(tile);
                }
                render();
              }
            });
            handDiv.appendChild(tileEl);
          });
        }
        console.log('Hand populated');

        if (isMyTurn && state.gameState.status === 'playing') {
          const playBtn = document.getElementById('playBtn');
          const cancelBtn = document.getElementById('cancelBtn');
          const swapBtn = document.getElementById('swapBtn');
          if (playBtn) playBtn.onclick = playTiles;
          if (cancelBtn) cancelBtn.onclick = () => { state.pendingPlacements = []; render(); };
          if (swapBtn) swapBtn.onclick = swapTiles;
          console.log('Action buttons attached');
        }
        
        console.log('Game screen render complete!');
      }
    }

    // Wait for scripts to load, then render
    window.addEventListener('load', () => {
      console.log('Window loaded, rendering menu');
      setTimeout(() => {
        render();
      }, 100);
    });
  </script>
</body>
</html>
