<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwirkle Online</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: Arial, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container { 
      max-width: 1200px; 
      margin: 0 auto; 
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    input, button {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      margin-bottom: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    button {
      cursor: pointer;
      color: white;
      border: none;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    button:hover:not(:disabled) { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-green { background: #27ae60; }
    .btn-blue { background: #3498db; }
    .btn-red { background: #e74c3c; }
    .btn-orange { background: #f39c12; }
    .tile {
      width: 50px;
      height: 50px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 2px solid #ccc;
      border-radius: 4px;
      cursor: grab;
      font-size: 32px;
      user-select: none;
    }
    .tile.selected { border: 3px solid #e74c3c; }
    
    /* Last move highlight animation */
    .tile.last-move {
      border: 3px solid #f39c12;
      box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
      animation: glow-pulse 2s ease-in-out infinite;
    }
    
    @keyframes glow-pulse {
      0%, 100% {
        box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
      }
      50% {
        box-shadow: 0 0 25px rgba(243, 156, 18, 0.8);
      }
    }
    
    .board-cell {
      width: 60px;
      height: 60px;
      border: 1px solid #bdc3c7;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .board-row { display: flex; }
    .board-container { 
      overflow-x: auto; 
      border: 2px solid #34495e; 
      border-radius: 5px; 
      background: #ecf0f1;
      margin: 20px 0;
    }
    .player-card {
      padding: 10px 15px;
      border-radius: 5px;
      margin: 5px;
      display: inline-block;
    }
    .hand-container { display: flex; gap: 10px; flex-wrap: wrap; margin: 20px 0; }
    h1, h2, h3 { color: #2c3e50; margin-bottom: 15px; }
    .game-id { 
      background: #ecf0f1; 
      padding: 15px; 
      border-radius: 5px; 
      margin-bottom: 20px;
      font-size: 18px;
    }
    .status-bar {
      padding: 10px;
      border-radius: 5px;
      text-align: center;
      color: white;
      margin-bottom: 20px;
      font-weight: bold;
    }
    .error-msg {
      background: #e74c3c;
      color: white;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="app">
      <div class="loading">
        <h1>üéÆ Qwirkle Online</h1>
        <p>Loading Firebase...</p>
        <p style="font-size: 14px; margin-top: 10px;">If this takes more than 5 seconds, check your internet connection.</p>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script>
    console.log('Script starting...');
    
    // Check if Firebase loaded
    if (typeof firebase === 'undefined') {
      document.getElementById('app').innerHTML = `
        <div class="error-msg">
          <h2>${t('firebaseError')}</h2>
          <p>${t('firebaseErrorDesc')}</p>
          <ul>
            <li>${t('poorConnection')}</li>
            <li>${t('firewall')}</li>
            <li>${t('browserSettings')}</li>
          </ul>
          <p style="margin-top: 10px;">${t('tryRefresh')}</p>
          <ul>
            <li>${t('refreshPage')}</li>
            <li>${t('disableAdblock')}</li>
            <li>${t('differentBrowser')}</li>
          </ul>
        </div>
      `;
      throw new Error('Firebase not loaded');
    }

    console.log('Firebase loaded successfully');

    const firebaseConfig = {
      apiKey: "AIzaSyBZvdbCflscZGDpV62zlycN6kEHOPnGjoE",
      authDomain: "qwirkle-5ebab.firebaseapp.com",
      databaseURL: "https://qwirkle-5ebab-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "qwirkle-5ebab",
      storageBucket: "qwirkle-5ebab.firebasestorage.app",
      messagingSenderId: "333453624833",
      appId: "1:333453624833:web:b679c5899f384818ce2200"
    };

    let db;
    let auth;
    
    async function initializeFirebase() {
      try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.database();
        auth = firebase.auth();
        console.log('Firebase initialized successfully');
        
        // Sign in anonymously
        await auth.signInAnonymously();
        console.log('Signed in anonymously with UID:', auth.currentUser.uid);
        
        return true;
      } catch (error) {
        console.error('Firebase initialization error:', error);
        document.getElementById('app').innerHTML = `
          <div class="error-msg">
            <h2>${t('firebaseInitError')}</h2>
            <p>${error.message}</p>
            <p>${t('refreshTryAgain')}</p>
          </div>
        `;
        throw error;
      }
    }

    const SHAPES = ['circle', 'square', 'diamond', 'star', 'cross', 'clover'];
    const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
    const SHAPE_ICONS = { circle: '‚óè', square: '‚ñ†', diamond: '‚óÜ', star: '‚òÖ', cross: '‚úö', clover: '‚ô£' };
    const COLOR_MAP = { red: '#ff4081', orange: '#8B4513', yellow: '#f1c40f', green: '#2ecc71', blue: '#3498db', purple: '#9b59b6' };

    let state = {
      screen: 'menu',
      playerName: '',
      gameId: '',
      playerId: localStorage.getItem('qwirklePlayerId') || '',
      gameState: null,
      selectedTiles: [],
      pendingPlacements: [],
      draggedTile: null,
      tileToPlace: null,  // For click-to-place mode
      language: localStorage.getItem('qwirkleLanguage') || 'en',
      reconnecting: false
    };

    const translations = {
      en: {
        title: 'Qwirkle Online',
        yourName: 'Your name',
        createGame: 'Create New Game',
        or: 'OR',
        gameId: 'Game ID',
        joinGame: 'Join Game',
        gameLobby: 'Game Lobby',
        shareId: 'Share this ID with friends!',
        players: 'Players',
        waitingHost: 'Waiting for host to start the game...',
        startGame: 'Start Game',
        bag: 'Bag',
        tiles: 'tiles',
        gameOver: 'Game Over!',
        winner: 'Winner',
        yourTurn: 'Your turn!',
        turn: "'s turn",
        yourHand: 'Your Hand',
        howToPlay: 'How to Play:',
        placeOne: 'Place one tile:',
        placeOneDesc: 'Click a tile in your hand, then click an empty spot on the board',
        placeMultiple: 'Place multiple tiles:',
        placeMultipleDesc: 'Click multiple tiles (they turn red), then click "Play" to place them all',
        swapTiles: 'Swap tiles:',
        swapTilesDesc: 'Select tiles (they turn red), then click "Swap"',
        removeTile: 'Remove a placed tile:',
        removeTileDesc: 'Click on a yellow tile to remove it from the board',
        playButton: 'Play',
        clearBoard: 'Clear Board',
        swap: 'Swap',
        tile: 'tile',
        pts: 'pts',
        clickTilePlace: 'Click a tile to place it, or select multiple to swap',
        clickToPlace: 'Click on the board to place your tile',
        tilesSelectedSwap: 'tiles selected. Click "Swap" or select more tiles.',
        firebaseError: 'Firebase Failed to Load',
        firebaseErrorDesc: 'Could not connect to the game server. This might be due to:',
        poorConnection: 'Poor internet connection',
        firewall: 'Firewall or network restrictions blocking Firebase',
        browserSettings: 'Browser settings blocking scripts',
        tryRefresh: 'Try these solutions:',
        refreshPage: 'Refresh the page',
        disableAdblock: 'Temporarily disable ad blockers',
        differentBrowser: 'Try a different browser',
        firebaseInitError: 'Firebase Initialization Error',
        refreshTryAgain: 'Please refresh the page to try again.',
        language: 'Language',
        reconnecting: 'Reconnecting to your game...',
        pleaseWait: 'Please wait...',
        leaveGame: 'Leave Game',
        confirmLeave: 'Are you sure you want to leave this game? You will not be able to rejoin.',
        playerLeft: 'left the game',
        thisMove: 'This Move:',
        points: 'points',
        you: 'You'
      },
      ru: {
        title: 'Qwirkle –û–Ω–ª–∞–π–Ω',
        yourName: '–í–∞—à–µ –∏–º—è',
        createGame: '–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É',
        or: '–ò–õ–ò',
        gameId: 'ID –∏–≥—Ä—ã',
        joinGame: '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∏–≥—Ä–µ',
        gameLobby: '–õ–æ–±–±–∏ –∏–≥—Ä—ã',
        shareId: '–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–∏–º ID —Å –¥—Ä—É–∑—å—è–º–∏!',
        players: '–ò–≥—Ä–æ–∫–∏',
        waitingHost: '–û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã —Ö–æ—Å—Ç–æ–º...',
        startGame: '–ù–∞—á–∞—Ç—å –∏–≥—Ä—É',
        bag: '–ú–µ—à–æ–∫',
        tiles: '—Ñ–∏—à–µ–∫',
        gameOver: '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!',
        winner: '–ü–æ–±–µ–¥–∏—Ç–µ–ª—å',
        yourTurn: '–í–∞—à —Ö–æ–¥!',
        turn: ' —Ö–æ–¥–∏—Ç',
        yourHand: '–í–∞—à–∏ —Ñ–∏—à–∫–∏',
        howToPlay: '–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:',
        placeOne: '–ü–æ—Å—Ç–∞–≤–∏—Ç—å –æ–¥–Ω—É —Ñ–∏—à–∫—É:',
        placeOneDesc: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ñ–∏—à–∫—É (–∑–µ–ª—ë–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ), –∑–∞—Ç–µ–º –Ω–∞ –¥–æ—Å–∫—É',
        placeMultiple: '–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∏—à–µ–∫:',
        placeMultipleDesc: '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∏—à–∫–∏ –∏–∑ —Ä—É–∫–∏ –Ω–∞ –¥–æ—Å–∫—É',
        swapTiles: '–û–±–º–µ–Ω—è—Ç—å —Ñ–∏—à–∫–∏:',
        swapTilesDesc: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ 2+ —Ñ–∏—à–∫–∏ (–∫—Ä–∞—Å–Ω–∞—è —Ä–∞–º–∫–∞), –∑–∞—Ç–µ–º "–û–±–º–µ–Ω—è—Ç—å"',
        removeTile: '–£–±—Ä–∞—Ç—å –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—É—é —Ñ–∏—à–∫—É:',
        removeTileDesc: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∂—ë–ª—Ç—É—é —Ñ–∏—à–∫—É –Ω–∞ –¥–æ—Å–∫–µ',
        playButton: '–°—ã–≥—Ä–∞—Ç—å',
        clearBoard: '–û—á–∏—Å—Ç–∏—Ç—å –¥–æ—Å–∫—É',
        swap: '–û–±–º–µ–Ω—è—Ç—å',
        tile: '—Ñ–∏—à–∫—É',
        pts: '–æ—á–∫.',
        clickTilePlace: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ñ–∏—à–∫—É, –∑–∞—Ç–µ–º –∫—É–¥–∞ –µ—ë –ø–æ—Å—Ç–∞–≤–∏—Ç—å',
        clickToPlace: '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –¥–æ—Å–∫—É, —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ñ–∏—à–∫—É',
        tilesSelectedSwap: '—Ñ–∏—à–µ–∫ –≤—ã–±—Ä–∞–Ω–æ –¥–ª—è –æ–±–º–µ–Ω–∞',
        firebaseError: '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Firebase',
        firebaseErrorDesc: '–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ Firebase –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å. –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑-–∑–∞:',
        poorConnection: '–ü–ª–æ—Ö–æ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è',
        firewall: '–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Å–∫—Ä–∏–ø—Ç–æ–≤ —Ñ–∞–π—Ä–≤–æ–ª–æ–º –∏–ª–∏ –±–ª–æ–∫–∏—Ä–æ–≤—â–∏–∫–æ–º —Ä–µ–∫–ª–∞–º—ã',
        browserSettings: '–ù–∞—Å—Ç—Ä–æ–µ–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –±—Ä–∞—É–∑–µ—Ä–∞',
        tryRefresh: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:',
        refreshPage: '–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É',
        disableAdblock: '–û—Ç–∫–ª—é—á–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤—â–∏–∫–∏ —Ä–µ–∫–ª–∞–º—ã',
        differentBrowser: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π –±—Ä–∞—É–∑–µ—Ä',
        firebaseInitError: '–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Firebase',
        refreshTryAgain: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.',
        language: '–Ø–∑—ã–∫',
        reconnecting: '–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –≤–∞—à–µ–π –∏–≥—Ä–µ...',
        pleaseWait: '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...',
        leaveGame: '–í—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã',
        confirmLeave: '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã? –í—ã –Ω–µ —Å–º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å—Å—è.',
        playerLeft: '–≤—ã—à–µ–ª –∏–∑ –∏–≥—Ä—ã',
        thisMove: '–≠—Ç–æ—Ç —Ö–æ–¥:',
        points: '–æ—á–∫–æ–≤',
        you: '–í—ã'
      }
    };

    function t(key) {
      return translations[state.language][key] || translations.en[key] || key;
    }

    function toggleLanguage() {
      state.language = state.language === 'en' ? 'ru' : 'en';
      localStorage.setItem('qwirkleLanguage', state.language);
      render();
    }

    function generateGameId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function generatePlayerId() {
      return 'p_' + Math.random().toString(36).substring(2, 15);
    }

    function createDeck() {
      const deck = [];
      let id = 0;
      SHAPES.forEach(shape => {
        COLORS.forEach(color => {
          for (let i = 0; i < 3; i++) {
            deck.push({ id: id++, shape, color });
          }
        });
      });
      return shuffle(deck);
    }

    function shuffle(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    async function createGame() {
      if (!state.playerName.trim()) {
        alert('Please enter your name');
        return;
      }
      
      try {
        // Use Firebase Auth UID as player ID
        const newPlayerId = auth.currentUser.uid;
        state.playerId = newPlayerId;
        localStorage.setItem('qwirklePlayerId', newPlayerId);

        const deck = createDeck();
        const player1Hand = deck.splice(0, 6);
        
        const newGameRef = db.ref('games').push();
        const newGameId = newGameRef.key;
        
        await newGameRef.set({
          players: { [newPlayerId]: { name: state.playerName, hand: player1Hand, score: 0, order: 0 } },
          deck: deck,
          board: {},
          currentPlayerIndex: 0,
          playerOrder: [newPlayerId],
          status: 'waiting',
          createdAt: Date.now(),
          lastMove: null
        });

        state.gameId = newGameId;
        
        // Save to localStorage for reconnection
        localStorage.setItem('qwirkleGameId', newGameId);
        localStorage.setItem('qwirklePlayerName', state.playerName);
        
        state.screen = 'lobby';
        render();
        listenToGame();
      } catch (error) {
        console.error('Error creating game:', error);
        alert('Error creating game: ' + error.message);
      }
    }

    async function joinGame() {
      if (!state.playerName.trim() || !state.gameId.trim()) {
        alert('Please enter both game ID and your name');
        return;
      }
      
      try {
        // Use Firebase Auth UID as player ID
        const newPlayerId = auth.currentUser.uid;
        state.playerId = newPlayerId;
        localStorage.setItem('qwirklePlayerId', newPlayerId);

        const snapshot = await db.ref(`games/${state.gameId}`).once('value');
        const game = snapshot.val();
        
        if (!game) {
          alert('Game not found!');
          return;
        }
        
        if (game.status !== 'waiting') {
          alert('Game already started!');
          return;
        }

        const deck = game.deck;
        const newHand = deck.splice(0, 6);
        
        await db.ref(`games/${state.gameId}/players/${newPlayerId}`).set({
          name: state.playerName,
          hand: newHand,
          score: 0,
          order: Object.keys(game.players).length
        });
        
        await db.ref(`games/${state.gameId}/deck`).set(deck);
        await db.ref(`games/${state.gameId}/playerOrder/${Object.keys(game.players).length}`).set(newPlayerId);

        // Save to localStorage for reconnection
        localStorage.setItem('qwirkleGameId', state.gameId);
        localStorage.setItem('qwirklePlayerName', state.playerName);

        state.screen = 'lobby';
        render();
        listenToGame();
      } catch (error) {
        console.error('Error joining game:', error);
        alert('Error joining game: ' + error.message);
      }
    }

    async function startGame() {
      try {
        await db.ref(`games/${state.gameId}`).update({ status: 'playing' });
        state.screen = 'game';
      } catch (error) {
        alert('Error starting game: ' + error.message);
      }
    }

    async function leaveGame() {
      // Confirm before leaving
      if (!confirm(t('confirmLeave'))) {
        return;
      }

      try {
        const gameId = state.gameId;
        const playerId = state.playerId;
        
        if (gameId && playerId && state.gameState) {
          // Get current game state
          const snapshot = await db.ref(`games/${gameId}`).once('value');
          const game = snapshot.val();
          
          if (game && game.players[playerId]) {
            const leavingPlayer = game.players[playerId];
            const playerIndex = game.playerOrder.indexOf(playerId);
            
            // Return player's tiles to the deck
            const playerHand = leavingPlayer.hand || [];
            const newDeck = [...game.deck, ...playerHand];
            
            // Shuffle the deck
            for (let i = newDeck.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            
            // Create new player order without this player
            const newPlayerOrder = game.playerOrder.filter(pid => pid !== playerId);
            
            // Adjust currentPlayerIndex if needed
            let newCurrentIndex = game.currentPlayerIndex;
            if (playerIndex < game.currentPlayerIndex) {
              // If a player before the current player leaves, shift index back
              newCurrentIndex = Math.max(0, game.currentPlayerIndex - 1);
            } else if (playerIndex === game.currentPlayerIndex) {
              // If current player leaves, move to next player
              newCurrentIndex = game.currentPlayerIndex % Math.max(1, newPlayerOrder.length);
            }
            
            // Ensure index is valid
            if (newCurrentIndex >= newPlayerOrder.length) {
              newCurrentIndex = 0;
            }
            
            // Prepare updates
            const updates = {
              deck: newDeck,
              playerOrder: newPlayerOrder,
              currentPlayerIndex: newCurrentIndex,
              [`players/${playerId}`]: null // Remove player
            };
            
            // If only one player left or no players, end the game
            if (newPlayerOrder.length <= 1) {
              updates.status = 'finished';
            }
            
            // Update the game in Firebase
            await db.ref(`games/${gameId}`).update(updates);
          }
        }
      } catch (error) {
        console.error('Error leaving game:', error);
        alert('Error leaving game: ' + error.message);
      }

      // Stop listening to the current game
      if (state.gameId) {
        db.ref(`games/${state.gameId}`).off();
      }

      // Clear all local game state
      state.gameId = '';
      state.playerId = '';
      state.playerName = '';
      state.gameState = null;
      state.selectedTiles = [];
      state.pendingPlacements = [];
      state.draggedTile = null;
      state.tileToPlace = null;
      state.screen = 'menu';

      // Clear localStorage
      localStorage.removeItem('qwirkleGameId');
      localStorage.removeItem('qwirklePlayerId');
      localStorage.removeItem('qwirklePlayerName');

      // Render menu
      render();
    }

    async function tryReconnect() {
      const savedGameId = localStorage.getItem('qwirkleGameId');
      const savedPlayerId = localStorage.getItem('qwirklePlayerId');
      const savedPlayerName = localStorage.getItem('qwirklePlayerName');

      if (!savedGameId || !savedPlayerId || !savedPlayerName) {
        return false;
      }

      try {
        state.reconnecting = true;
        render();

        const snapshot = await db.ref(`games/${savedGameId}`).once('value');
        const game = snapshot.val();

        if (!game) {
          // Game no longer exists
          localStorage.removeItem('qwirkleGameId');
          localStorage.removeItem('qwirklePlayerName');
          state.reconnecting = false;
          return false;
        }

        // Check if player is in the game
        if (!game.players[savedPlayerId]) {
          // Player not in game
          localStorage.removeItem('qwirkleGameId');
          localStorage.removeItem('qwirklePlayerName');
          state.reconnecting = false;
          return false;
        }

        // Successfully reconnected
        state.gameId = savedGameId;
        state.playerId = savedPlayerId;
        state.playerName = savedPlayerName;
        state.gameState = game;
        state.reconnecting = false;

        if (game.status === 'waiting') {
          state.screen = 'lobby';
        } else {
          state.screen = 'game';
        }

        listenToGame();
        render();
        return true;
      } catch (error) {
        console.error('Reconnection error:', error);
        state.reconnecting = false;
        localStorage.removeItem('qwirkleGameId');
        localStorage.removeItem('qwirklePlayerName');
        return false;
      }
    }

    function listenToGame() {
      db.ref(`games/${state.gameId}`).on('value', (snapshot) => {
        if (!snapshot.exists()) {
          alert('Game no longer exists');
          state.screen = 'menu';
          render();
          return;
        }

        const game = snapshot.val();
        state.gameState = game;

        if (game.status === 'waiting') {
          state.screen = 'lobby';
        } else if (game.status === 'playing' || game.status === 'finished') {
          state.screen = 'game';
        }

        render();
      });
    }

    function validatePlacement(placements, board) {
      if (placements.length === 0) return { valid: false, reason: 'No tiles placed' };

      // Ensure board is an object, even if it's undefined/null
      board = board || {};
      
      const newBoard = { ...board };
      placements.forEach(p => { newBoard[`${p.row},${p.col}`] = p.tile; });

      const rows = placements.map(p => p.row);
      const cols = placements.map(p => p.col);
      const sameRow = rows.every(r => r === rows[0]);
      const sameCol = cols.every(c => c === cols[0]);

      if (!sameRow && !sameCol) return { valid: false, reason: 'Tiles must be in same row or column' };

      if (sameRow) {
        const sortedCols = [...cols].sort((a, b) => a - b);
        for (let i = 0; i < sortedCols.length - 1; i++) {
          for (let c = sortedCols[i] + 1; c < sortedCols[i + 1]; c++) {
            if (!newBoard[`${rows[0]},${c}`]) return { valid: false, reason: 'Tiles must be continuous' };
          }
        }
      } else {
        const sortedRows = [...rows].sort((a, b) => a - b);
        for (let i = 0; i < sortedRows.length - 1; i++) {
          for (let r = sortedRows[i] + 1; r < sortedRows[i + 1]; r++) {
            if (!newBoard[`${r},${cols[0]}`]) return { valid: false, reason: 'Tiles must be continuous' };
          }
        }
      }

      // Find ALL lines that are affected by this placement
      // We need to check:
      // 1. The main line where tiles are placed
      // 2. ALL perpendicular lines that intersect with placed tiles
      // 3. ALL perpendicular lines that intersect with the entire contiguous group
      
      const linesToCheck = new Set();
      
      if (sameRow) {
        const row = rows[0];
        
        // Check the main horizontal line
        linesToCheck.add(`row-${row}`);
        
        // Find the full extent of the horizontal line (including existing tiles)
        let minCol = Math.min(...cols);
        let maxCol = Math.max(...cols);
        
        // Extend to include any contiguous tiles
        while (newBoard[`${row},${minCol - 1}`]) minCol--;
        while (newBoard[`${row},${maxCol + 1}`]) maxCol++;
        
        // Check ALL columns in the affected range
        for (let c = minCol; c <= maxCol; c++) {
          if (newBoard[`${row},${c}`]) {
            linesToCheck.add(`col-${c}`);
          }
        }
      } else {
        const col = cols[0];
        
        // Check the main vertical line
        linesToCheck.add(`col-${col}`);
        
        // Find the full extent of the vertical line (including existing tiles)
        let minRow = Math.min(...rows);
        let maxRow = Math.max(...rows);
        
        // Extend to include any contiguous tiles
        while (newBoard[`${minRow - 1},${col}`]) minRow--;
        while (newBoard[`${maxRow + 1},${col}`]) maxRow++;
        
        // Check ALL rows in the affected range
        for (let r = minRow; r <= maxRow; r++) {
          if (newBoard[`${r},${col}`]) {
            linesToCheck.add(`row-${r}`);
          }
        }
      }

      console.log('Lines to check:', Array.from(linesToCheck).sort());

      for (const line of linesToCheck) {
        const [type, pos] = line.split('-');
        const position = parseInt(pos);
        
        // Find all contiguous segments in this line
        const segments = [];
        let currentSegment = [];
        
        if (type === 'row') {
          for (let c = -50; c <= 50; c++) {
            const tile = newBoard[`${position},${c}`];
            if (tile) {
              currentSegment.push(tile);
            } else if (currentSegment.length > 0) {
              segments.push([...currentSegment]);
              currentSegment = [];
            }
          }
        } else {
          for (let r = -50; r <= 50; r++) {
            const tile = newBoard[`${r},${position}`];
            if (tile) {
              currentSegment.push(tile);
            } else if (currentSegment.length > 0) {
              segments.push([...currentSegment]);
              currentSegment = [];
            }
          }
        }
        if (currentSegment.length > 0) segments.push(currentSegment);
        
        // Validate each contiguous segment
        for (const tiles of segments) {
          if (tiles.length > 6) return { valid: false, reason: 'Line cannot be longer than 6' };

          if (tiles.length > 1) {
            const colors = tiles.map(t => t.color);
            const shapes = tiles.map(t => t.shape);
            const uniqueColors = new Set(colors);
            const uniqueShapes = new Set(shapes);

            const allSameColor = uniqueColors.size === 1;
            const allSameShape = uniqueShapes.size === 1;

            // Must be either all same color OR all same shape
            if (!allSameColor && !allSameShape) {
              console.log('Line validation failed - mixed attributes:', { colors, shapes, line });
              return { valid: false, reason: 'Line must share color or shape' };
            }
            
            // If all same color, all shapes must be different (no duplicate shapes)
            if (allSameColor && uniqueShapes.size !== tiles.length) {
              console.log('Duplicate shapes detected in line', line, ':', shapes);
              return { valid: false, reason: 'Duplicate tiles - same color requires different shapes' };
            }
            
            // If all same shape, all colors must be different (no duplicate colors)
            if (allSameShape && uniqueColors.size !== tiles.length) {
              console.log('Duplicate colors detected in line', line, ':', colors);
              return { valid: false, reason: 'Duplicate tiles - same shape requires different colors' };
            }
          }
        }
      }

      if (Object.keys(board).length === 0) return { valid: true, score: calculateScore(placements, newBoard).score };

      let connected = false;
      for (const p of placements) {
        const adjacent = [
          newBoard[`${p.row - 1},${p.col}`],
          newBoard[`${p.row + 1},${p.col}`],
          newBoard[`${p.row},${p.col - 1}`],
          newBoard[`${p.row},${p.col + 1}`]
        ];
        if (adjacent.some(t => t && !placements.find(pl => pl.tile.id === t.id))) {
          connected = true;
          break;
        }
      }

      if (!connected) return { valid: false, reason: 'Must connect to existing tiles' };
      return { valid: true, score: calculateScore(placements, newBoard).score };
    }

    function calculateScore(placements, board) {
      // Ensure board is an object
      board = board || {};
      
      const debugInfo = [];
      debugInfo.push('=== SCORING DETAILS ===');
      debugInfo.push(`Placed: ${placements.map(p => `${p.tile.color} ${p.tile.shape} at (${p.row},${p.col})`).join(', ')}`);
      
      let totalScore = 0;
      const scoredLines = new Set();

      // Determine if placement is horizontal or vertical
      const rows = placements.map(p => p.row);
      const cols = placements.map(p => p.col);
      const sameRow = rows.every(r => r === rows[0]);
      const sameCol = cols.every(c => c === cols[0]);

      debugInfo.push(`Type: ${sameRow ? 'HORIZONTAL' : sameCol ? 'VERTICAL' : 'SINGLE'}`);
      debugInfo.push('');

      if (sameRow) {
        // Horizontal placement - score the horizontal line ONCE
        const row = rows[0];
        let rowTiles = [];
        
        // Use the first placement as starting point and go both directions
        const startCol = cols[0];
        
        // Go LEFT from first placement
        let leftTiles = [];
        for (let c = startCol - 1; c >= -50; c--) {
          const tile = board[`${row},${c}`];
          if (tile) leftTiles.unshift(tile);
          else break;
        }
        
        // Add all placed tiles (they're contiguous)
        rowTiles = [...leftTiles];
        const minPlacedCol = Math.min(...cols);
        const maxPlacedCol = Math.max(...cols);
        for (let c = minPlacedCol; c <= maxPlacedCol; c++) {
          const tile = board[`${row},${c}`];
          if (tile) rowTiles.push(tile);
        }
        
        // Go RIGHT from last placement
        for (let c = maxPlacedCol + 1; c <= 50; c++) {
          const tile = board[`${row},${c}`];
          if (tile) rowTiles.push(tile);
          else break;
        }
        
        debugInfo.push(`Horizontal Line (Row ${row}):`);
        debugInfo.push(`  ${rowTiles.length} tiles: ${rowTiles.map(t => `${t.color} ${t.shape}`).join(', ')}`);
        if (rowTiles.length > 1) {
          let score = rowTiles.length;
          if (rowTiles.length === 6) score += 6;
          debugInfo.push(`  Score: ${score} points`);
          totalScore += score;
        } else {
          debugInfo.push(`  Score: 0 (need 2+ tiles)`);
        }
        debugInfo.push('');
        
        // Score each PERPENDICULAR (vertical) line for each placed tile
        placements.forEach((p, idx) => {
          let colTiles = [];
          
          // Start from the placed tile and collect in both directions
          // Go UP (decreasing row)
          let upTiles = [];
          for (let r = p.row - 1; r >= -50; r--) {
            const tile = board[`${r},${p.col}`];
            if (tile) upTiles.unshift(tile); // Add to front
            else break; // Stop at gap
          }
          
          // Add the placed tile itself
          colTiles = [...upTiles, board[`${p.row},${p.col}`]];
          
          // Go DOWN (increasing row)
          for (let r = p.row + 1; r <= 50; r++) {
            const tile = board[`${r},${p.col}`];
            if (tile) colTiles.push(tile);
            else break; // Stop at gap
          }
          
          debugInfo.push(`Vertical Line ${idx + 1} (Col ${p.col}):`);
          debugInfo.push(`  ${colTiles.length} tiles: ${colTiles.map(t => `${t.color} ${t.shape}`).join(', ')}`);
          if (colTiles.length > 1) {
            let score = colTiles.length;
            if (colTiles.length === 6) score += 6;
            debugInfo.push(`  Score: ${score} points`);
            totalScore += score;
          } else {
            debugInfo.push(`  Score: 0 (need 2+ tiles)`);
          }
          debugInfo.push('');
        });
      } else if (sameCol) {
        // Vertical placement - score the vertical line ONCE
        const col = cols[0];
        let colTiles = [];
        
        // Use the first placement as starting point and go both directions
        const startRow = rows[0];
        
        // Go UP from first placement
        let upTiles = [];
        for (let r = startRow - 1; r >= -50; r--) {
          const tile = board[`${r},${col}`];
          if (tile) upTiles.unshift(tile);
          else break;
        }
        
        // Add all placed tiles (they're contiguous)
        colTiles = [...upTiles];
        const minPlacedRow = Math.min(...rows);
        const maxPlacedRow = Math.max(...rows);
        for (let r = minPlacedRow; r <= maxPlacedRow; r++) {
          const tile = board[`${r},${col}`];
          if (tile) colTiles.push(tile);
        }
        
        // Go DOWN from last placement
        for (let r = maxPlacedRow + 1; r <= 50; r++) {
          const tile = board[`${r},${col}`];
          if (tile) colTiles.push(tile);
          else break;
        }
        
        debugInfo.push(`Vertical Line (Col ${col}):`);
        debugInfo.push(`  ${colTiles.length} tiles: ${colTiles.map(t => `${t.color} ${t.shape}`).join(', ')}`);
        if (colTiles.length > 1) {
          let score = colTiles.length;
          if (colTiles.length === 6) score += 6;
          debugInfo.push(`  Score: ${score} points`);
          totalScore += score;
        } else {
          debugInfo.push(`  Score: 0 (need 2+ tiles)`);
        }
        debugInfo.push('');
        
        // Score each PERPENDICULAR (horizontal) line for each placed tile
        placements.forEach((p, idx) => {
          let rowTiles = [];
          
          // Start from the placed tile and collect in both directions
          // Go LEFT (decreasing col)
          let leftTiles = [];
          for (let c = p.col - 1; c >= -50; c--) {
            const tile = board[`${p.row},${c}`];
            if (tile) leftTiles.unshift(tile); // Add to front
            else break; // Stop at gap
          }
          
          // Add the placed tile itself
          rowTiles = [...leftTiles, board[`${p.row},${p.col}`]];
          
          // Go RIGHT (increasing col)
          for (let c = p.col + 1; c <= 50; c++) {
            const tile = board[`${p.row},${c}`];
            if (tile) rowTiles.push(tile);
            else break; // Stop at gap
          }
          
          debugInfo.push(`Horizontal Line ${idx + 1} (Row ${p.row}):`);
          debugInfo.push(`  ${rowTiles.length} tiles: ${rowTiles.map(t => `${t.color} ${t.shape}`).join(', ')}`);
          if (rowTiles.length > 1) {
            let score = rowTiles.length;
            if (rowTiles.length === 6) score += 6;
            debugInfo.push(`  Score: ${score} points`);
            totalScore += score;
          } else {
            debugInfo.push(`  Score: 0 (need 2+ tiles)`);
          }
          debugInfo.push('');
        });
      }

      // If no lines were scored (single tile not connecting to anything), score the placement count
      if (totalScore === 0 && placements.length > 0) {
        debugInfo.push('No lines scored - using placement count');
        totalScore = placements.length;
      }
      
      debugInfo.push('====================');
      debugInfo.push(`TOTAL SCORE: ${totalScore}`);
      
      // Show alert with scoring details
      // Only show during actual play, not during preview (to avoid spam)
      if (window.showScoringDebug) {
        alert(debugInfo.join('\n'));
      }
      
      // Always log to console for debugging
      console.log(debugInfo.join('\n'));
      
      // Return both score and debug info
      return {
        score: totalScore,
        debugInfo: debugInfo
      };
    }

    async function playTiles() {
      if (state.pendingPlacements.length === 0) return;

      try {
        const currentBoard = state.gameState.board || {};
        
        // Enable scoring debug alert for this play
        window.showScoringDebug = true;
        
        const validation = validatePlacement(state.pendingPlacements, currentBoard);
        
        // Disable debug flag after validation
        window.showScoringDebug = false;
        
        if (!validation.valid) { 
          alert(validation.reason); 
          return; 
        }

        const newBoard = { ...currentBoard };
        const placedTileIds = [];
        
        state.pendingPlacements.forEach(p => { 
          const tileToStore = {
            shape: p.tile.shape,
            color: p.tile.color,
            id: p.tile.id
          };
          newBoard[`${p.row},${p.col}`] = tileToStore;
          placedTileIds.push(`${p.row},${p.col}`);
        });

        const currentPlayer = state.gameState.players[state.playerId];
        const newHand = currentPlayer.hand.filter(t => !state.pendingPlacements.find(p => p.tile.id === t.id));

        let newDeck = [...state.gameState.deck];
        const tilesToDraw = Math.min(state.pendingPlacements.length, newDeck.length);
        const drawnTiles = newDeck.splice(0, tilesToDraw);
        newHand.push(...drawnTiles);

        const newScore = currentPlayer.score + validation.score;
        const nextPlayerIndex = (state.gameState.currentPlayerIndex + 1) % state.gameState.playerOrder.length;

        // Store last move information for highlighting
        const lastMove = {
          playerId: state.playerId,
          tiles: placedTileIds,
          timestamp: Date.now()
        };

        const updates = {
          board: newBoard,
          deck: newDeck,
          [`players/${state.playerId}/hand`]: newHand,
          [`players/${state.playerId}/score`]: newScore,
          currentPlayerIndex: nextPlayerIndex,
          lastMove: lastMove
        };

        if (newDeck.length === 0 && newHand.length === 0) {
          updates[`players/${state.playerId}/score`] = newScore + 6;
          updates.status = 'finished';
        }

        await db.ref(`games/${state.gameId}`).update(updates);
        
        state.pendingPlacements = [];
        state.selectedTiles = [];
        state.tileToPlace = null;
        render();
      } catch (error) {
        console.error('Error in playTiles:', error);
        alert('Error playing tiles: ' + error.message);
      }
    }

    async function swapTiles() {
      if (state.selectedTiles.length === 0 || state.gameState.deck.length < state.selectedTiles.length) {
        alert('Cannot swap - not enough tiles in bag');
        return;
      }

      try {
        const currentPlayer = state.gameState.players[state.playerId];
        const newHand = currentPlayer.hand.filter(t => !state.selectedTiles.find(s => s.id === t.id));

        let newDeck = [...state.gameState.deck];
        const drawn = newDeck.splice(0, state.selectedTiles.length);
        newHand.push(...drawn);
        newDeck.push(...state.selectedTiles);
        newDeck.sort(() => Math.random() - 0.5);

        const nextPlayerIndex = (state.gameState.currentPlayerIndex + 1) % state.gameState.playerOrder.length;

        await db.ref(`games/${state.gameId}`).update({
          deck: newDeck,
          [`players/${state.playerId}/hand`]: newHand,
          currentPlayerIndex: nextPlayerIndex,
          lastMove: null
        });

        state.selectedTiles = [];
        state.tileToPlace = null;
        render();
      } catch (error) {
        console.error('Error swapping tiles:', error);
        alert('Error swapping tiles: ' + error.message);
      }
    }

    function renderTile(tile, options = {}) {
      const el = document.createElement('div');
      el.className = 'tile';
      if (options.selected) el.classList.add('selected');
      if (options.lastMove) el.classList.add('last-move');
      el.style.color = COLOR_MAP[tile.color];
      el.textContent = SHAPE_ICONS[tile.shape];
      el.draggable = options.draggable || false;
      
      if (options.onDragStart) {
        el.ondragstart = (e) => {
          options.onDragStart();
        };
      }
      
      if (options.onClick) {
        el.onclick = (e) => {
          e.stopPropagation();
          options.onClick();
        };
        el.style.cursor = 'pointer';
      }
      
      return el;
    }

    function render() {
      console.log('Rendering screen:', state.screen);
      const app = document.getElementById('app');
      
      if (state.reconnecting) {
        app.innerHTML = `
          <div style="text-align: center; padding: 40px;">
            <h1>üîÑ ${t('reconnecting')}</h1>
            <p style="color: #7f8c8d; margin-top: 20px;">${t('pleaseWait')}</p>
          </div>
        `;
        return;
      }
      
      if (state.screen === 'menu') {
        app.innerHTML = `
          <div style="text-align: right; margin-bottom: 20px;">
            <button onclick="toggleLanguage()" style="width: auto; padding: 8px 16px; background: #95a5a6; cursor: pointer;">
              ${state.language === 'en' ? 'üá∑üá∫ –†—É—Å—Å–∫–∏–π' : 'üá¨üáß English'}
            </button>
          </div>
          <h1 style="text-align: center;">${t('title')}</h1>
          <div style="max-width: 500px; margin: 0 auto;">
            <input type="text" id="playerName" placeholder="${t('yourName')}" value="${state.playerName}">
            <button class="btn-green" id="createBtn">${t('createGame')}</button>
            <div style="margin: 20px 0; text-align: center; color: #7f8c8d;">${t('or')}</div>
            <input type="text" id="gameIdInput" placeholder="${t('gameId')}" value="${state.gameId}">
            <button class="btn-blue" id="joinBtn">${t('joinGame')}</button>
          </div>
        `;
        
        const nameInput = document.getElementById('playerName');
        const gameInput = document.getElementById('gameIdInput');
        const createBtn = document.getElementById('createBtn');
        const joinBtn = document.getElementById('joinBtn');
        
        window.toggleLanguage = toggleLanguage;
        
        nameInput.oninput = (e) => state.playerName = e.target.value;
        gameInput.oninput = (e) => state.gameId = e.target.value;
        createBtn.onclick = createGame;
        joinBtn.onclick = joinGame;
        
        // Auto-focus name input
        setTimeout(() => document.getElementById('nameInput')?.focus(), 100);
      }
      else if (state.screen === 'lobby' && state.gameState) {
        const isHost = state.gameState.playerOrder[0] === state.playerId;
        const playerCount = Object.keys(state.gameState.players).length;

        app.innerHTML = `
          <h1 style="text-align: center;">${t('gameLobby')}</h1>
          <div class="game-id">
            <strong>${t('gameId')}:</strong> <span style="font-size: 24px; color: #2c3e50;">${state.gameId}</span>
            <p style="font-size: 14px; color: #7f8c8d; margin-top: 10px;">${t('shareId')}</p>
          </div>
          <h3>${t('players')} (${playerCount}/4):</h3>
          <div id="playerList"></div>
          ${isHost && playerCount >= 2 ? `<button class="btn-green" id="startBtn">${t('startGame')}</button>` : ''}
          ${!isHost ? `<p style="text-align: center; color: #7f8c8d; margin-top: 20px;">${t('waitingHost')}</p>` : ''}
          <button class="btn-red" id="leaveBtn" style="margin-top: 10px;">${t('leaveGame')}</button>
        `;

        const playerList = document.getElementById('playerList');
        Object.entries(state.gameState.players).forEach(([id, player]) => {
          const div = document.createElement('div');
          div.className = 'player-card';
          div.style.background = '#ecf0f1';
          div.textContent = `${player.name}${id === state.playerId ? ` (${t('you')})` : ''}${id === state.gameState.playerOrder[0] ? ' üëë' : ''}`;
          playerList.appendChild(div);
        });

        if (isHost && playerCount >= 2) {
          document.getElementById('startBtn').onclick = startGame;
        }
        
        document.getElementById('leaveBtn').onclick = leaveGame;
      }
      else if (state.screen === 'game' && state.gameState) {
        const currentPlayer = state.gameState.players[state.playerId];
        
        if (!currentPlayer) {
          app.innerHTML = `<div class="error-msg"><h2>Error</h2><p>Player data not found. Please refresh the page.</p></div>`;
          return;
        }

        const board = state.gameState.board || {};

        // Calculate board dimensions
        let minRow = 0, maxRow = 0, minCol = 0, maxCol = 0;
        Object.keys(board).forEach(key => {
          const [row, col] = key.split(',').map(Number);
          minRow = Math.min(minRow, row);
          maxRow = Math.max(maxRow, row);
          minCol = Math.min(minCol, col);
          maxCol = Math.max(maxCol, col);
        });

        // Add padding and account for pending placements
        state.pendingPlacements.forEach(p => {
          minRow = Math.min(minRow, p.row);
          maxRow = Math.max(maxRow, p.row);
          minCol = Math.min(minCol, p.col);
          maxCol = Math.max(maxCol, p.col);
        });

        minRow -= 2; maxRow += 2; minCol -= 2; maxCol += 2;

        const isMyTurn = state.gameState.currentPlayerIndex === state.gameState.playerOrder.indexOf(state.playerId);
        const currentTurnPlayerId = state.gameState.playerOrder[state.gameState.currentPlayerIndex];
        const currentTurnPlayer = state.gameState.players[currentTurnPlayerId];
        
        // If current turn player has left, this shouldn't happen but handle it gracefully
        const currentPlayerName = currentTurnPlayer ? currentTurnPlayer.name : 'Unknown Player';

        console.log('Creating game HTML structure...');
        app.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1>${t('title')}</h1>
            <div style="background: #ecf0f1; padding: 10px 15px; border-radius: 5px;">
              <strong>${t('gameId')}:</strong> ${state.gameId} | <strong>${t('bag')}:</strong> ${state.gameState.deck.length} ${t('tiles')}
            </div>
          </div>
          <div id="scores" style="margin-bottom: 20px;"></div>
          ${state.gameState.status === 'finished' ? `
            <div class="status-bar" style="background: #e74c3c;">
              ${t('gameOver')} ${t('winner')}: ${Object.entries(state.gameState.players).sort((a, b) => b[1].score - a[1].score)[0][1].name}
            </div>
          ` : ''}
          ${isMyTurn && state.gameState.status === 'playing' ? `
            <div class="status-bar" style="background: ${isMyTurn ? '#27ae60' : '#95a5a6'};">
              ${isMyTurn ? (state.tileToPlace ? `üìç ${t('clickToPlace')}` : state.selectedTiles.length > 0 ? `üîÑ ${state.selectedTiles.length} ${t('tilesSelectedSwap')}` : `üëÜ ${t('clickTilePlace')}`) : `${currentPlayerName}${t('turn')}`}
            </div>
          ` : state.gameState.status === 'playing' ? `
            <div class="status-bar" style="background: #95a5a6;">
              ${currentPlayerName}${t('turn')}
            </div>
          ` : ''}
          <div class="board-container">
            <div style="display: inline-block; padding: 20px;" id="board"></div>
          </div>
          <h3>${t('yourHand')}</h3>
          <div class="hand-container" id="hand"></div>
          ${isMyTurn && state.gameState.status === 'playing' ? `
            <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin: 15px 0; font-size: 14px;">
              <strong>${t('howToPlay')}</strong><br>
              ‚Ä¢ <strong>${t('placeOne')}</strong> ${t('placeOneDesc')}<br>
              ‚Ä¢ <strong>${t('placeMultiple')}</strong> ${t('placeMultipleDesc')}<br>
              ‚Ä¢ <strong>${t('swapTiles')}</strong> ${t('swapTilesDesc')}<br>
              ‚Ä¢ <strong>${t('removeTile')}</strong> ${t('removeTileDesc')}
            </div>
            ${state.pendingPlacements.length > 0 ? `
              <div id="scorePreview" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin: 20px 0; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 10px; font-weight: bold;">${t('thisMove')}</div>
                <div style="font-size: 32px; font-weight: bold; margin-bottom: 10px;" id="scoreValue">calculating...</div>
                <div id="scoreBreakdown" style="font-size: 12px; opacity: 0.9; text-align: left; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; max-height: 200px; overflow-y: auto;"></div>
              </div>
            ` : ''}
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px;">
              <button class="btn-green" id="playBtn" ${state.pendingPlacements.length === 0 ? 'disabled' : ''}>‚úì ${t('playButton')} ${state.pendingPlacements.length} ${state.pendingPlacements.length === 1 ? t('tile') : t('tiles')}</button>
              <button class="btn-red" id="cancelBtn" ${state.pendingPlacements.length === 0 ? 'disabled' : ''}>‚úï ${t('clearBoard')}</button>
              <button class="btn-orange" id="swapBtn" ${state.selectedTiles.length === 0 || state.gameState.deck.length < state.selectedTiles.length ? 'disabled' : ''}>üîÑ ${t('swap')} ${state.selectedTiles.length > 0 ? state.selectedTiles.length + ' ' + (state.selectedTiles.length === 1 ? t('tile') : t('tiles')) : t('tiles')}</button>
            </div>
          ` : ''}
          <div style="margin-top: 20px;">
            <button class="btn-red" id="leaveGameBtn" style="width: auto; padding: 10px 20px;">üö™ ${t('leaveGame')}</button>
          </div>
        `;

        console.log('HTML structure created, populating scores...');
        const scoresDiv = document.getElementById('scores');
        if (!scoresDiv) {
          console.error('Scores div not found!');
          return;
        }
        
        // Create a header for the players section
        const playersHeader = document.createElement('h2');
        playersHeader.textContent = t('players');
        playersHeader.style.marginBottom = '10px';
        scoresDiv.appendChild(playersHeader);
        
        const playersContainer = document.createElement('div');
        playersContainer.style.display = 'flex';
        playersContainer.style.flexWrap = 'wrap';
        playersContainer.style.gap = '10px';
        
        state.gameState.playerOrder.forEach((pid, idx) => {
          const p = state.gameState.players[pid];
          
          // Skip if player has left (their data was removed)
          if (!p) return;
          
          const isCurrent = idx === state.gameState.currentPlayerIndex;
          const isYou = pid === state.playerId;
          
          const card = document.createElement('div');
          card.className = 'player-card';
          card.style.background = isCurrent ? '#3498db' : '#ecf0f1';
          card.style.color = isCurrent ? 'white' : 'black';
          card.style.padding = '15px 20px';
          card.style.borderRadius = '8px';
          card.style.fontWeight = 'bold';
          card.style.fontSize = '16px';
          
          if (isYou) {
            card.style.border = '3px solid #27ae60';
            card.style.boxShadow = '0 0 10px rgba(39, 174, 96, 0.3)';
          }
          
          const nameSpan = document.createElement('div');
          nameSpan.textContent = `${p.name}${isYou ? ` (${t('you')})` : ''}${isCurrent ? ' üéØ' : ''}`;
          nameSpan.style.fontSize = '18px';
          nameSpan.style.marginBottom = '5px';
          
          const scoreSpan = document.createElement('div');
          scoreSpan.textContent = `${t('pts')}: ${p.score}`;
          scoreSpan.style.fontSize = '14px';
          scoreSpan.style.opacity = '0.9';
          
          card.appendChild(nameSpan);
          card.appendChild(scoreSpan);
          playersContainer.appendChild(card);
        });
        
        scoresDiv.appendChild(playersContainer);
        console.log('Scores populated');

        console.log('Creating board...');
        const boardDiv = document.getElementById('board');
        
        // Check if current player has made any action (placed tile or swapped)
        const currentPlayerHasActed = state.pendingPlacements.length > 0 || 
                                       (state.gameState.lastMove && 
                                        state.gameState.lastMove.playerId === state.playerId);
        
        for (let row = minRow; row <= maxRow; row++) {
          const rowDiv = document.createElement('div');
          rowDiv.className = 'board-row';
          for (let col = minCol; col <= maxCol; col++) {
            const key = `${row},${col}`;
            const tile = board[key];
            const pending = state.pendingPlacements.find(p => p.row === row && p.col === col);
            
            const cell = document.createElement('div');
            cell.className = 'board-cell';
            const canPlace = isMyTurn && state.tileToPlace && !tile && !pending;
            cell.style.background = pending ? '#ffffcc' : tile ? 'white' : '#f8f9fa';
            cell.style.cursor = canPlace ? 'pointer' : 'default';
            
            // Hover effect for valid placement spots
            if (canPlace) {
              cell.onmouseenter = () => { cell.style.background = '#d4edda'; };
              cell.onmouseleave = () => { cell.style.background = '#f8f9fa'; };
            }
            
            // Click to place tile
            cell.onclick = () => {
              if (state.tileToPlace && isMyTurn && !tile && !pending) {
                state.pendingPlacements.push({ row, col, tile: state.tileToPlace });
                state.tileToPlace = null;
                render();
              }
            };
            
            // Drag and drop (backup method)
            cell.ondragover = (e) => e.preventDefault();
            cell.ondrop = (e) => {
              e.preventDefault();
              if (state.draggedTile && isMyTurn && !tile && !pending) {
                state.pendingPlacements.push({ row, col, tile: state.draggedTile });
                state.draggedTile = null;
                render();
              }
            };

            if (tile) {
              // Check if this tile is part of the last move and should be highlighted
              const isLastMove = !currentPlayerHasActed && 
                                state.gameState.lastMove && 
                                state.gameState.lastMove.tiles && 
                                state.gameState.lastMove.tiles.includes(key);
              
              cell.appendChild(renderTile(tile, { lastMove: isLastMove }));
            }
            if (pending) {
              const pendingTile = renderTile(pending.tile, {
                onClick: () => {
                  state.pendingPlacements = state.pendingPlacements.filter(p => p !== pending);
                  render();
                }
              });
              pendingTile.style.opacity = '0.8';
              cell.appendChild(pendingTile);
            }
            
            rowDiv.appendChild(cell);
          }
          boardDiv.appendChild(rowDiv);
        }
        console.log('Board created');

        console.log('Creating hand with', currentPlayer.hand ? currentPlayer.hand.length : 0, 'tiles');
        const handDiv = document.getElementById('hand');
        if (!handDiv) {
          console.error('Hand div not found!');
          return;
        }
        if (currentPlayer.hand && Array.isArray(currentPlayer.hand)) {
          currentPlayer.hand.forEach(tile => {
            const isSelectedForSwap = state.selectedTiles.find(t => t.id === tile.id);
            const isSelectedForPlacement = state.tileToPlace && state.tileToPlace.id === tile.id;
            const isAlreadyPlaced = state.pendingPlacements.find(p => p.tile.id === tile.id);
            
            if (isAlreadyPlaced) return; // Don't show tiles that are already placed
            
            const tileEl = renderTile(tile, {
              draggable: true,
              selected: isSelectedForSwap,
              onDragStart: () => { state.draggedTile = tile; },
              onClick: () => {
                if (!isMyTurn) return;
                
                // If clicking the tile that's selected for placement, deselect it
                if (isSelectedForPlacement) {
                  state.tileToPlace = null;
                  render();
                  return;
                }
                
                // If clicking a tile that's selected for swap, deselect it
                if (isSelectedForSwap) {
                  state.selectedTiles = state.selectedTiles.filter(t => t.id !== tile.id);
                  // If we now have exactly 1 tile selected, make it placement mode
                  if (state.selectedTiles.length === 1) {
                    state.tileToPlace = state.selectedTiles[0];
                    state.selectedTiles = [];
                  }
                  render();
                  return;
                }
                
                // If we already have tiles selected for swap, add this one too
                if (state.selectedTiles.length > 0) {
                  state.selectedTiles.push(tile);
                  render();
                  return;
                }
                
                // If we have a placement tile selected, switch to multi-select (swap mode)
                if (state.tileToPlace) {
                  state.selectedTiles = [state.tileToPlace, tile];
                  state.tileToPlace = null;
                  render();
                  return;
                }
                
                // Otherwise, select this tile for placement
                state.tileToPlace = tile;
                render();
              }
            });
            
            // Highlight tile selected for placement (green)
            if (isSelectedForPlacement) {
              tileEl.style.border = '3px solid #27ae60';
              tileEl.style.boxShadow = '0 0 10px rgba(39, 174, 96, 0.5)';
            }
            
            // Highlight tiles selected for swap (red)
            if (isSelectedForSwap) {
              tileEl.style.border = '3px solid #e74c3c';
            }
            
            handDiv.appendChild(tileEl);
          });
        }
        console.log('Hand populated');

        if (isMyTurn && state.gameState.status === 'playing') {
          const playBtn = document.getElementById('playBtn');
          const cancelBtn = document.getElementById('cancelBtn');
          const swapBtn = document.getElementById('swapBtn');
          if (playBtn) playBtn.onclick = playTiles;
          if (cancelBtn) cancelBtn.onclick = () => { 
            state.pendingPlacements = []; 
            state.tileToPlace = null;
            render(); 
          };
          if (swapBtn) swapBtn.onclick = swapTiles;
          
          // Calculate and display score preview if there are pending placements
          if (state.pendingPlacements.length > 0) {
            const scoreValueEl = document.getElementById('scoreValue');
            const scoreBreakdownEl = document.getElementById('scoreBreakdown');
            if (scoreValueEl && scoreBreakdownEl) {
              try {
                // Create temporary board with pending placements
                const tempBoard = { ...board };
                state.pendingPlacements.forEach(p => {
                  tempBoard[`${p.row},${p.col}`] = p.tile;
                });
                
                // Calculate score with debug info
                const result = calculateScore(state.pendingPlacements, tempBoard);
                
                // Display with animation
                scoreValueEl.style.opacity = '0';
                scoreBreakdownEl.style.opacity = '0';
                setTimeout(() => {
                  scoreValueEl.textContent = result.score + ' ' + t('points');
                  scoreValueEl.style.opacity = '1';
                  scoreValueEl.style.transition = 'opacity 0.3s ease-in-out';
                  
                  // Show breakdown without the header and total (those are shown separately)
                  const breakdown = result.debugInfo.slice(2, -2).join('\n');
                  scoreBreakdownEl.textContent = breakdown;
                  scoreBreakdownEl.style.opacity = '1';
                  scoreBreakdownEl.style.transition = 'opacity 0.3s ease-in-out';
                }, 50);
              } catch (error) {
                console.error('Error calculating score preview:', error);
                scoreValueEl.textContent = '?';
                scoreBreakdownEl.textContent = 'Error: ' + error.message;
              }
            }
          }
        }
        
        // Add leave game button handler
        const leaveGameBtn = document.getElementById('leaveGameBtn');
        if (leaveGameBtn) leaveGameBtn.onclick = leaveGame;
      }
    }

    // Wait for scripts to load, initialize Firebase, then try to reconnect or render menu
    window.addEventListener('load', async () => {
      console.log('Window loaded');
      
      // Initialize Firebase and sign in anonymously
      await initializeFirebase();
      
      setTimeout(async () => {
        const reconnected = await tryReconnect();
        if (!reconnected) {
          render();
        }
      }, 100);
    });
  </script>
</body>
</html>
