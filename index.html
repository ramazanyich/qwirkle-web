<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qwirkle Online</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: Arial, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container { 
      max-width: 1200px; 
      margin: 0 auto; 
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    input, button {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      margin-bottom: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    button {
      cursor: pointer;
      color: white;
      border: none;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    button:hover:not(:disabled) { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-green { background: #27ae60; }
    .btn-blue { background: #3498db; }
    .btn-red { background: #e74c3c; }
    .btn-orange { background: #f39c12; }
    .tile {
      width: 50px;
      height: 50px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 2px solid #ccc;
      border-radius: 4px;
      cursor: grab;
      font-size: 32px;
      user-select: none;
    }
    .tile.selected { border: 3px solid #e74c3c; }
    
    /* Last move highlight animation */
    .tile.last-move {
      border: 3px solid #f39c12;
      box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
      animation: glow-pulse 2s ease-in-out infinite;
    }
    
    @keyframes glow-pulse {
      0%, 100% {
        box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
      }
      50% {
        box-shadow: 0 0 25px rgba(243, 156, 18, 0.8);
      }
    }
    
    .board-cell {
      width: 60px;
      height: 60px;
      border: 1px solid #bdc3c7;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .board-row { display: flex; }
    .board-container { 
      overflow-x: auto; 
      border: 2px solid #34495e; 
      border-radius: 5px; 
      background: #ecf0f1;
      margin: 20px 0;
    }
    .player-card {
      padding: 10px 15px;
      border-radius: 5px;
      margin: 5px;
      display: inline-block;
    }
    .hand-container { display: flex; gap: 10px; flex-wrap: wrap; margin: 20px 0; }
    h1, h2, h3 { color: #2c3e50; margin-bottom: 15px; }
    .game-id { 
      background: #ecf0f1; 
      padding: 15px; 
      border-radius: 5px; 
      margin-bottom: 20px;
      font-size: 18px;
    }
    .status-bar {
      padding: 10px;
      border-radius: 5px;
      text-align: center;
      color: white;
      margin-bottom: 20px;
      font-weight: bold;
    }
    .error-msg {
      background: #e74c3c;
      color: white;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="app">
      <div class="loading">
        <h1>ðŸŽ® Qwirkle Online</h1>
        <p>Loading Firebase...</p>
        <p style="font-size: 14px; margin-top: 10px;">If this takes more than 5 seconds, check your internet connection.</p>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script>
    console.log('Script starting...');
    
    // Check if Firebase loaded
    if (typeof firebase === 'undefined') {
      document.getElementById('app').innerHTML = `
        <div class="error-msg">
          <h2>${t('firebaseError')}</h2>
          <p>${t('firebaseErrorDesc')}</p>
          <ul>
            <li>${t('poorConnection')}</li>
            <li>${t('firewall')}</li>
            <li>${t('browserSettings')}</li>
          </ul>
          <p style="margin-top: 10px;">${t('tryRefresh')}</p>
          <ul>
            <li>${t('refreshPage')}</li>
            <li>${t('disableAdblock')}</li>
            <li>${t('differentBrowser')}</li>
          </ul>
        </div>
      `;
      throw new Error('Firebase not loaded');
    }

    console.log('Firebase loaded successfully');

    const firebaseConfig = {
      apiKey: "AIzaSyBZvdbCflscZGDpV62zlycN6kEHOPnGjoE",
      authDomain: "qwirkle-5ebab.firebaseapp.com",
      databaseURL: "https://qwirkle-5ebab-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "qwirkle-5ebab",
      storageBucket: "qwirkle-5ebab.firebasestorage.app",
      messagingSenderId: "333453624833",
      appId: "1:333453624833:web:b679c5899f384818ce2200"
    };

    let db;
    try {
      firebase.initializeApp(firebaseConfig);
      db = firebase.database();
      console.log('Firebase initialized successfully');
    } catch (error) {
      console.error('Firebase initialization error:', error);
      document.getElementById('app').innerHTML = `
        <div class="error-msg">
          <h2>${t('firebaseInitError')}</h2>
          <p>${error.message}</p>
          <p>${t('refreshTryAgain')}</p>
        </div>
      `;
      throw error;
    }

    const SHAPES = ['circle', 'square', 'diamond', 'star', 'cross', 'clover'];
    const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
    const SHAPE_ICONS = { circle: 'â—', square: 'â– ', diamond: 'â—†', star: 'â˜…', cross: 'âœš', clover: 'â™£' };
    const COLOR_MAP = { red: '#ff4081', orange: '#8B4513', yellow: '#f1c40f', green: '#2ecc71', blue: '#3498db', purple: '#9b59b6' };

    let state = {
      screen: 'menu',
      playerName: '',
      gameId: '',
      playerId: localStorage.getItem('qwirklePlayerId') || '',
      gameState: null,
      selectedTiles: [],
      pendingPlacements: [],
      draggedTile: null,
      tileToPlace: null,  // For click-to-place mode
      language: localStorage.getItem('qwirkleLanguage') || 'en'
    };

    const translations = {
      en: {
        title: 'Qwirkle Online',
        yourName: 'Your name',
        createGame: 'Create New Game',
        or: 'OR',
        gameId: 'Game ID',
        joinGame: 'Join Game',
        gameLobby: 'Game Lobby',
        shareId: 'Share this ID with friends!',
        players: 'Players',
        waitingHost: 'Waiting for host to start the game...',
        startGame: 'Start Game',
        bag: 'Bag',
        tiles: 'tiles',
        gameOver: 'Game Over!',
        winner: 'Winner',
        yourTurn: 'Your turn!',
        turn: "'s turn",
        yourHand: 'Your Hand',
        howToPlay: 'How to Play:',
        placeOne: 'Place one tile:',
        placeOneDesc: 'Click a tile in your hand, then click an empty spot on the board',
        placeMultiple: 'Place multiple tiles:',
        placeMultipleDesc: 'Click multiple tiles (they turn red), then click "Play" to place them all',
        swapTiles: 'Swap tiles:',
        swapTilesDesc: 'Select tiles (they turn red), then click "Swap"',
        removeTile: 'Remove a placed tile:',
        removeTileDesc: 'Click on a yellow tile to remove it from the board',
        playButton: 'Play',
        clearBoard: 'Clear Board',
        swap: 'Swap',
        tile: 'tile',
        pts: 'pts',
        clickTilePlace: 'Click a tile to place it, or select multiple to swap',
        clickToPlace: 'Click on the board to place your tile',
        tilesSelectedSwap: 'tiles selected. Click "Swap" or select more tiles.',
        firebaseError: 'Firebase Failed to Load',
        firebaseErrorDesc: 'Could not connect to the game server. This might be due to:',
        poorConnection: 'Poor internet connection',
        firewall: 'Firewall or network restrictions blocking Firebase',
        browserSettings: 'Browser settings blocking scripts',
        tryRefresh: 'Try these solutions:',
        refreshPage: 'Refresh the page',
        disableAdblock: 'Temporarily disable ad blockers',
        differentBrowser: 'Try a different browser',
        firebaseInitError: 'Firebase Initialization Error',
        refreshTryAgain: 'Please refresh the page to try again.',
        language: 'Language'
      },
      pl: {
        title: 'Qwirkle Online',
        yourName: 'Twoje imiÄ™',
        createGame: 'UtwÃ³rz nowÄ… grÄ™',
        or: 'LUB',
        gameId: 'ID Gry',
        joinGame: 'DoÅ‚Ä…cz do gry',
        gameLobby: 'Poczekalnia',
        shareId: 'UdostÄ™pnij to ID znajomym!',
        players: 'Gracze',
        waitingHost: 'Czekam aÅ¼ gospodarz rozpocznie grÄ™...',
        startGame: 'Rozpocznij grÄ™',
        bag: 'Woreczek',
        tiles: 'kafelkÃ³w',
        gameOver: 'Koniec gry!',
        winner: 'ZwyciÄ™zca',
        yourTurn: 'Twoja kolej!',
        turn: ' - kolej',
        yourHand: 'Twoje kafelki',
        howToPlay: 'Jak graÄ‡:',
        placeOne: 'PoÅ‚oÅ¼ jeden kafelek:',
        placeOneDesc: 'Kliknij kafelek w rÄ™ce, nastÄ™pnie kliknij puste miejsce na planszy',
        placeMultiple: 'PoÅ‚oÅ¼ wiele kafelkÃ³w:',
        placeMultipleDesc: 'Kliknij wiele kafelkÃ³w (stanÄ… siÄ™ czerwone), nastÄ™pnie kliknij "Zagraj"',
        swapTiles: 'WymieÅ„ kafelki:',
        swapTilesDesc: 'Wybierz kafelki (stanÄ… siÄ™ czerwone), nastÄ™pnie kliknij "WymieÅ„"',
        removeTile: 'UsuÅ„ poÅ‚oÅ¼ony kafelek:',
        removeTileDesc: 'Kliknij na Å¼Ã³Å‚ty kafelek aby go usunÄ…Ä‡ z planszy',
        playButton: 'Zagraj',
        clearBoard: 'WyczyÅ›Ä‡ planszÄ™',
        swap: 'WymieÅ„',
        tile: 'kafelek',
        pts: 'pkt',
        clickTilePlace: 'Kliknij kafelek aby go poÅ‚oÅ¼yÄ‡, lub wybierz wiele do wymiany',
        clickToPlace: 'Kliknij na planszÄ™ aby poÅ‚oÅ¼yÄ‡ kafelek',
        tilesSelectedSwap: 'kafelkÃ³w zaznaczonych. Kliknij "WymieÅ„" lub zaznacz wiÄ™cej.',
        firebaseError: 'Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ Firebase',
        firebaseErrorDesc: 'Nie moÅ¼na poÅ‚Ä…czyÄ‡ siÄ™ z serwerem gry. MoÅ¼e to byÄ‡ spowodowane:',
        poorConnection: 'SÅ‚abym poÅ‚Ä…czeniem internetowym',
        firewall: 'Firewallem lub ograniczeniami sieciowymi blokujÄ…cymi Firebase',
        browserSettings: 'Ustawieniami przeglÄ…darki blokujÄ…cymi skrypty',
        tryRefresh: 'SprÃ³buj tych rozwiÄ…zaÅ„:',
        refreshPage: 'OdÅ›wieÅ¼ stronÄ™',
        disableAdblock: 'Tymczasowo wyÅ‚Ä…cz blokady reklam',
        differentBrowser: 'SprÃ³buj innej przeglÄ…darki',
        firebaseInitError: 'BÅ‚Ä…d inicjalizacji Firebase',
        refreshTryAgain: 'OdÅ›wieÅ¼ stronÄ™ aby sprÃ³bowaÄ‡ ponownie.',
        language: 'JÄ™zyk'
      }
    };

    function t(key) {
      return translations[state.language][key] || translations.en[key] || key;
    }

    function setLanguage(lang) {
      state.language = lang;
      localStorage.setItem('qwirkleLanguage', lang);
      render();
    }

    function generateGameId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function generatePlayerId() {
      return 'p_' + Math.random().toString(36).substring(2, 15);
    }

    function createDeck() {
      const deck = [];
      let id = 0;
      SHAPES.forEach(shape => {
        COLORS.forEach(color => {
          for (let i = 0; i < 3; i++) {
            deck.push({ id: id++, shape, color });
          }
        });
      });
      return shuffle(deck);
    }

    function shuffle(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    async function createGame() {
      const name = document.getElementById('nameInput').value.trim();
      if (!name) {
        alert('Please enter your name');
        return;
      }

      const gameId = generateGameId();
      const playerId = state.playerId || generatePlayerId();
      
      const deck = createDeck();
      const initialHand = deck.splice(0, 6);

      await db.ref(`games/${gameId}`).set({
        status: 'lobby',
        host: playerId,
        deck: deck,
        board: {},
        players: {
          [playerId]: {
            name: name,
            hand: initialHand,
            score: 0
          }
        },
        playerOrder: [playerId],
        currentPlayerIndex: 0,
        lastMove: null,
        createdAt: Date.now()
      });

      state.playerId = playerId;
      state.playerName = name;
      state.gameId = gameId;
      localStorage.setItem('qwirklePlayerId', playerId);
      
      state.screen = 'lobby';
      render();
      listenToGame(gameId);
    }

    async function joinGame() {
      const gameId = document.getElementById('gameIdInput').value.trim().toUpperCase();
      const name = document.getElementById('nameInput').value.trim();
      
      if (!gameId || !name) {
        alert('Please enter both game ID and your name');
        return;
      }

      const gameSnapshot = await db.ref(`games/${gameId}`).once('value');
      if (!gameSnapshot.exists()) {
        alert('Game not found!');
        return;
      }

      const game = gameSnapshot.val();
      if (game.status !== 'lobby') {
        alert('This game has already started!');
        return;
      }

      const playerId = state.playerId || generatePlayerId();
      
      const deck = game.deck;
      const hand = deck.splice(0, 6);

      await db.ref(`games/${gameId}/players/${playerId}`).set({
        name: name,
        hand: hand,
        score: 0
      });

      await db.ref(`games/${gameId}/deck`).set(deck);
      await db.ref(`games/${gameId}/playerOrder`).set([...game.playerOrder, playerId]);

      state.playerId = playerId;
      state.playerName = name;
      state.gameId = gameId;
      localStorage.setItem('qwirklePlayerId', playerId);
      
      state.screen = 'lobby';
      render();
      listenToGame(gameId);
    }

    async function startGame() {
      await db.ref(`games/${state.gameId}/status`).set('playing');
    }

    function listenToGame(gameId) {
      db.ref(`games/${gameId}`).on('value', (snapshot) => {
        if (!snapshot.exists()) {
          alert('Game no longer exists');
          state.screen = 'menu';
          render();
          return;
        }

        const game = snapshot.val();
        state.gameState = game;

        if (game.status === 'lobby') {
          state.screen = 'lobby';
        } else if (game.status === 'playing' || game.status === 'finished') {
          state.screen = 'game';
        }

        render();
      });
    }

    function isValidPlacement(placements, board) {
      if (placements.length === 0) return { valid: false, error: 'No tiles placed' };

      // Check all tiles are in same row OR same column
      const rows = [...new Set(placements.map(p => p.row))];
      const cols = [...new Set(placements.map(p => p.col))];
      
      if (rows.length > 1 && cols.length > 1) {
        return { valid: false, error: 'Tiles must be in a single row or column' };
      }

      // Check tiles are contiguous
      if (placements.length > 1) {
        const sorted = rows.length === 1 
          ? [...placements].sort((a, b) => a.col - b.col)
          : [...placements].sort((a, b) => a.row - b.row);
        
        for (let i = 0; i < sorted.length - 1; i++) {
          const current = sorted[i];
          const next = sorted[i + 1];
          const gap = rows.length === 1 
            ? next.col - current.col 
            : next.row - current.row;
          
          if (gap !== 1) {
            // Check if there's a tile filling the gap
            let hasGap = false;
            for (let j = 1; j < gap; j++) {
              const checkPos = rows.length === 1
                ? `${current.row},${current.col + j}`
                : `${current.row + j},${current.col}`;
              if (!board[checkPos]) {
                hasGap = true;
                break;
              }
            }
            if (hasGap) {
              return { valid: false, error: 'Tiles must be contiguous' };
            }
          }
        }
      }

      // Check each tile connects to existing tiles (unless first move)
      const boardHasTiles = Object.keys(board).length > 0;
      if (boardHasTiles) {
        let hasConnection = false;
        for (const p of placements) {
          const neighbors = [
            board[`${p.row-1},${p.col}`],
            board[`${p.row+1},${p.col}`],
            board[`${p.row},${p.col-1}`],
            board[`${p.row},${p.col+1}`]
          ];
          if (neighbors.some(n => n)) {
            hasConnection = true;
            break;
          }
        }
        if (!hasConnection) {
          return { valid: false, error: 'Tiles must connect to existing tiles' };
        }
      }

      // Build complete lines including existing tiles
      const tempBoard = { ...board };
      placements.forEach(p => {
        tempBoard[`${p.row},${p.col}`] = p.tile;
      });

      // Check lines for validity
      const checkedLines = new Set();
      
      for (const p of placements) {
        // Check horizontal line
        const rowKey = `row-${p.row}`;
        if (!checkedLines.has(rowKey)) {
          checkedLines.add(rowKey);
          const rowTiles = [];
          let col = p.col;
          
          // Find start of line
          while (tempBoard[`${p.row},${col-1}`]) col--;
          
          // Collect line
          while (tempBoard[`${p.row},${col}`]) {
            rowTiles.push(tempBoard[`${p.row},${col}`]);
            col++;
          }
          
          if (rowTiles.length > 1) {
            const lineCheck = checkLine(rowTiles);
            if (!lineCheck.valid) return lineCheck;
          }
        }

        // Check vertical line
        const colKey = `col-${p.col}`;
        if (!checkedLines.has(colKey)) {
          checkedLines.add(colKey);
          const colTiles = [];
          let row = p.row;
          
          // Find start of line
          while (tempBoard[`${row-1},${p.col}`]) row--;
          
          // Collect line
          while (tempBoard[`${row},${p.col}`]) {
            colTiles.push(tempBoard[`${row},${p.col}`]);
            row++;
          }
          
          if (colTiles.length > 1) {
            const lineCheck = checkLine(colTiles);
            if (!lineCheck.valid) return lineCheck;
          }
        }
      }

      return { valid: true };
    }

    function checkLine(tiles) {
      if (tiles.length > 6) {
        return { valid: false, error: 'Line cannot be longer than 6' };
      }

      const colors = tiles.map(t => t.color);
      const shapes = tiles.map(t => t.shape);
      
      const uniqueColors = new Set(colors);
      const uniqueShapes = new Set(shapes);
      
      // All same shape, different colors
      if (uniqueShapes.size === 1 && uniqueColors.size === tiles.length) {
        return { valid: true };
      }
      
      // All same color, different shapes
      if (uniqueColors.size === 1 && uniqueShapes.size === tiles.length) {
        return { valid: true };
      }
      
      return { valid: false, error: 'Line must be all same shape (different colors) or all same color (different shapes)' };
    }

    function calculateScore(placements, board) {
      const tempBoard = { ...board };
      placements.forEach(p => {
        tempBoard[`${p.row},${p.col}`] = p.tile;
      });

      let totalScore = 0;
      const scoredLines = new Set();

      for (const p of placements) {
        // Score horizontal line
        const rowKey = `row-${p.row}`;
        if (!scoredLines.has(rowKey)) {
          const rowTiles = [];
          let col = p.col;
          while (tempBoard[`${p.row},${col-1}`]) col--;
          while (tempBoard[`${p.row},${col}`]) {
            rowTiles.push(tempBoard[`${p.row},${col}`]);
            col++;
          }
          if (rowTiles.length > 1) {
            scoredLines.add(rowKey);
            totalScore += rowTiles.length;
            if (rowTiles.length === 6) totalScore += 6; // Qwirkle bonus
          }
        }

        // Score vertical line
        const colKey = `col-${p.col}`;
        if (!scoredLines.has(colKey)) {
          const colTiles = [];
          let row = p.row;
          while (tempBoard[`${row-1},${p.col}`]) row--;
          while (tempBoard[`${row},${p.col}`]) {
            colTiles.push(tempBoard[`${row},${p.col}`]);
            row++;
          }
          if (colTiles.length > 1) {
            scoredLines.add(colKey);
            totalScore += colTiles.length;
            if (colTiles.length === 6) totalScore += 6; // Qwirkle bonus
          }
        }
      }

      // If no lines scored (single tile), score 1 point
      if (totalScore === 0) totalScore = 1;

      return totalScore;
    }

    async function playTiles() {
      if (state.pendingPlacements.length === 0) return;

      const validation = isValidPlacement(state.pendingPlacements, state.gameState.board);
      if (!validation.valid) {
        alert(validation.error);
        return;
      }

      const score = calculateScore(state.pendingPlacements, state.gameState.board);
      const newBoard = { ...state.gameState.board };
      const placedTileIds = [];
      
      state.pendingPlacements.forEach(p => {
        newBoard[`${p.row},${p.col}`] = p.tile;
        placedTileIds.push(`${p.row},${p.col}`);
      });

      const currentPlayer = state.gameState.players[state.playerId];
      const newHand = currentPlayer.hand.filter(t => 
        !state.pendingPlacements.find(p => p.tile.id === t.id)
      );

      // Draw new tiles
      const deck = state.gameState.deck;
      const tilesToDraw = Math.min(state.pendingPlacements.length, deck.length);
      const drawnTiles = deck.splice(0, tilesToDraw);
      newHand.push(...drawnTiles);

      const newScore = currentPlayer.score + score;
      const nextPlayerIndex = (state.gameState.currentPlayerIndex + 1) % state.gameState.playerOrder.length;

      // Check if game is over
      let gameStatus = 'playing';
      if (deck.length === 0 && newHand.length === 0) {
        gameStatus = 'finished';
      }

      // Store last move information
      const lastMove = {
        playerId: state.playerId,
        tiles: placedTileIds,
        timestamp: Date.now()
      };

      await db.ref(`games/${state.gameId}`).update({
        board: newBoard,
        deck: deck,
        currentPlayerIndex: nextPlayerIndex,
        status: gameStatus,
        lastMove: lastMove,
        [`players/${state.playerId}/hand`]: newHand,
        [`players/${state.playerId}/score`]: newScore
      });

      state.pendingPlacements = [];
      state.tileToPlace = null;
      render();
    }

    async function swapTiles() {
      if (state.selectedTiles.length === 0) return;
      if (state.gameState.deck.length < state.selectedTiles.length) {
        alert('Not enough tiles in the bag to swap!');
        return;
      }

      const currentPlayer = state.gameState.players[state.playerId];
      const newHand = currentPlayer.hand.filter(t => 
        !state.selectedTiles.find(s => s.id === t.id)
      );

      const deck = state.gameState.deck;
      const drawnTiles = deck.splice(0, state.selectedTiles.length);
      newHand.push(...drawnTiles);
      deck.push(...state.selectedTiles);

      const nextPlayerIndex = (state.gameState.currentPlayerIndex + 1) % state.gameState.playerOrder.length;

      // Clear last move when swapping (so highlight disappears)
      await db.ref(`games/${state.gameId}`).update({
        deck: shuffle(deck),
        currentPlayerIndex: nextPlayerIndex,
        lastMove: null,
        [`players/${state.playerId}/hand`]: newHand
      });

      state.selectedTiles = [];
      render();
    }

    function renderTile(tile, options = {}) {
      const el = document.createElement('div');
      el.className = 'tile';
      if (options.selected) el.classList.add('selected');
      if (options.lastMove) el.classList.add('last-move');
      el.style.color = COLOR_MAP[tile.color];
      el.textContent = SHAPE_ICONS[tile.shape];
      el.draggable = options.draggable || false;
      
      if (options.onDragStart) {
        el.ondragstart = (e) => {
          options.onDragStart();
        };
      }
      
      if (options.onClick) {
        el.onclick = (e) => {
          e.stopPropagation();
          options.onClick();
        };
        el.style.cursor = 'pointer';
      }
      
      return el;
    }

    function render() {
      console.log('Rendering screen:', state.screen);
      const app = document.getElementById('app');
      
      if (state.screen === 'menu') {
        app.innerHTML = `
          <h1>${t('title')}</h1>
          <div style="text-align: right; margin-bottom: 20px;">
            <label>${t('language')}: </label>
            <select id="langSelect" style="width: auto; padding: 8px;">
              <option value="en" ${state.language === 'en' ? 'selected' : ''}>English</option>
              <option value="pl" ${state.language === 'pl' ? 'selected' : ''}>Polski</option>
            </select>
          </div>
          <input type="text" id="nameInput" placeholder="${t('yourName')}" value="${state.playerName}">
          <button class="btn-green" id="createBtn">${t('createGame')}</button>
          <div style="text-align: center; margin: 20px 0; color: #7f8c8d;">${t('or')}</div>
          <input type="text" id="gameIdInput" placeholder="${t('gameId')}" style="text-transform: uppercase;">
          <button class="btn-blue" id="joinBtn">${t('joinGame')}</button>
        `;

        document.getElementById('langSelect').onchange = (e) => {
          setLanguage(e.target.value);
        };
        document.getElementById('createBtn').onclick = createGame;
        document.getElementById('joinBtn').onclick = joinGame;
        
        // Auto-focus name input
        setTimeout(() => document.getElementById('nameInput')?.focus(), 100);
      }
      else if (state.screen === 'lobby') {
        const isHost = state.gameState.host === state.playerId;
        app.innerHTML = `
          <h1>${t('gameLobby')}</h1>
          <div class="game-id">
            <strong>${t('gameId')}:</strong> ${state.gameId}<br>
            <small>${t('shareId')}</small>
          </div>
          <h2>${t('players')}:</h2>
          <div id="playersList"></div>
          ${!isHost ? `<p style="margin-top: 20px; color: #7f8c8d;">${t('waitingHost')}</p>` : ''}
          ${isHost ? `<button class="btn-green" id="startBtn" ${Object.keys(state.gameState.players).length < 2 ? 'disabled' : ''}>${t('startGame')}</button>` : ''}
        `;

        const playersList = document.getElementById('playersList');
        Object.entries(state.gameState.players).forEach(([pid, player]) => {
          const div = document.createElement('div');
          div.className = 'player-card';
          div.style.background = '#ecf0f1';
          div.textContent = `${player.name}${pid === state.gameState.host ? ' ðŸ‘‘' : ''}`;
          playersList.appendChild(div);
        });

        if (isHost) {
          document.getElementById('startBtn').onclick = startGame;
        }
      }
      else if (state.screen === 'game') {
        console.log('Rendering game screen');
        const board = state.gameState.board || {};
        const currentPlayer = state.gameState.players[state.playerId];
        
        if (!currentPlayer) {
          console.error('Current player not found!');
          return;
        }

        // Calculate board dimensions
        let minRow = 0, maxRow = 0, minCol = 0, maxCol = 0;
        Object.keys(board).forEach(key => {
          const [row, col] = key.split(',').map(Number);
          minRow = Math.min(minRow, row);
          maxRow = Math.max(maxRow, row);
          minCol = Math.min(minCol, col);
          maxCol = Math.max(maxCol, col);
        });

        // Add padding and account for pending placements
        state.pendingPlacements.forEach(p => {
          minRow = Math.min(minRow, p.row);
          maxRow = Math.max(maxRow, p.row);
          minCol = Math.min(minCol, p.col);
          maxCol = Math.max(maxCol, p.col);
        });

        minRow -= 2; maxRow += 2; minCol -= 2; maxCol += 2;

        const isMyTurn = state.gameState.currentPlayerIndex === state.gameState.playerOrder.indexOf(state.playerId);
        const currentTurnPlayer = state.gameState.players[state.gameState.playerOrder[state.gameState.currentPlayerIndex]];

        console.log('Creating game HTML structure...');
        app.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1>${t('title')}</h1>
            <div style="background: #ecf0f1; padding: 10px 15px; border-radius: 5px;">
              <strong>${t('gameId')}:</strong> ${state.gameId} | <strong>${t('bag')}:</strong> ${state.gameState.deck.length} ${t('tiles')}
            </div>
          </div>
          <div id="scores" style="margin-bottom: 20px;"></div>
          ${state.gameState.status === 'finished' ? `
            <div class="status-bar" style="background: #e74c3c;">
              ${t('gameOver')} ${t('winner')}: ${Object.entries(state.gameState.players).sort((a, b) => b[1].score - a[1].score)[0][1].name}
            </div>
          ` : ''}
          ${isMyTurn && state.gameState.status === 'playing' ? `
            <div class="status-bar" style="background: ${isMyTurn ? '#27ae60' : '#95a5a6'};">
              ${isMyTurn ? (state.tileToPlace ? `ðŸ“ ${t('clickToPlace')}` : state.selectedTiles.length > 0 ? `ðŸ”„ ${state.selectedTiles.length} ${t('tilesSelectedSwap')}` : `ðŸ‘† ${t('clickTilePlace')}`) : `${currentTurnPlayer.name}${t('turn')}`}
            </div>
          ` : state.gameState.status === 'playing' ? `
            <div class="status-bar" style="background: #95a5a6;">
              ${currentTurnPlayer.name}${t('turn')}
            </div>
          ` : ''}
          <div class="board-container">
            <div style="display: inline-block; padding: 20px;" id="board"></div>
          </div>
          <h3>${t('yourHand')}</h3>
          <div class="hand-container" id="hand"></div>
          ${isMyTurn && state.gameState.status === 'playing' ? `
            <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin: 15px 0; font-size: 14px;">
              <strong>${t('howToPlay')}</strong><br>
              â€¢ <strong>${t('placeOne')}</strong> ${t('placeOneDesc')}<br>
              â€¢ <strong>${t('placeMultiple')}</strong> ${t('placeMultipleDesc')}<br>
              â€¢ <strong>${t('swapTiles')}</strong> ${t('swapTilesDesc')}<br>
              â€¢ <strong>${t('removeTile')}</strong> ${t('removeTileDesc')}
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px;">
              <button class="btn-green" id="playBtn" ${state.pendingPlacements.length === 0 ? 'disabled' : ''}>âœ“ ${t('playButton')} ${state.pendingPlacements.length} ${state.pendingPlacements.length === 1 ? t('tile') : t('tiles')}</button>
              <button class="btn-red" id="cancelBtn" ${state.pendingPlacements.length === 0 ? 'disabled' : ''}>âœ• ${t('clearBoard')}</button>
              <button class="btn-orange" id="swapBtn" ${state.selectedTiles.length === 0 || state.gameState.deck.length < state.selectedTiles.length ? 'disabled' : ''}>ðŸ”„ ${t('swap')} ${state.selectedTiles.length > 0 ? state.selectedTiles.length + ' ' + (state.selectedTiles.length === 1 ? t('tile') : t('tiles')) : t('tiles')}</button>
            </div>
          ` : ''}
        `;

        console.log('HTML structure created, populating scores...');
        const scoresDiv = document.getElementById('scores');
        if (!scoresDiv) {
          console.error('Scores div not found!');
          return;
        }
        state.gameState.playerOrder.forEach((pid, idx) => {
          const p = state.gameState.players[pid];
          const isCurrent = idx === state.gameState.currentPlayerIndex;
          const card = document.createElement('div');
          card.className = 'player-card';
          card.style.background = isCurrent ? '#3498db' : '#ecf0f1';
          card.style.color = isCurrent ? 'white' : 'black';
          if (pid === state.playerId) card.style.border = '3px solid #27ae60';
          card.textContent = `${p.name}: ${p.score} ${t('pts')}${isCurrent ? ' ðŸŽ¯' : ''}`;
          scoresDiv.appendChild(card);
        });
        console.log('Scores populated');

        console.log('Creating board...');
        const boardDiv = document.getElementById('board');
        
        // Check if current player has made any action (placed tile or swapped)
        const currentPlayerHasActed = state.pendingPlacements.length > 0 || 
                                       (state.gameState.lastMove && 
                                        state.gameState.lastMove.playerId === state.playerId);
        
        for (let row = minRow; row <= maxRow; row++) {
          const rowDiv = document.createElement('div');
          rowDiv.className = 'board-row';
          for (let col = minCol; col <= maxCol; col++) {
            const key = `${row},${col}`;
            const tile = board[key];
            const pending = state.pendingPlacements.find(p => p.row === row && p.col === col);
            
            const cell = document.createElement('div');
            cell.className = 'board-cell';
            const canPlace = isMyTurn && state.tileToPlace && !tile && !pending;
            cell.style.background = pending ? '#ffffcc' : tile ? 'white' : '#f8f9fa';
            cell.style.cursor = canPlace ? 'pointer' : 'default';
            
            // Hover effect for valid placement spots
            if (canPlace) {
              cell.onmouseenter = () => { cell.style.background = '#d4edda'; };
              cell.onmouseleave = () => { cell.style.background = '#f8f9fa'; };
            }
            
            // Click to place tile
            cell.onclick = () => {
              if (state.tileToPlace && isMyTurn && !tile && !pending) {
                state.pendingPlacements.push({ row, col, tile: state.tileToPlace });
                state.tileToPlace = null;
                render();
              }
            };
            
            // Drag and drop (backup method)
            cell.ondragover = (e) => e.preventDefault();
            cell.ondrop = (e) => {
              e.preventDefault();
              if (state.draggedTile && isMyTurn && !tile && !pending) {
                state.pendingPlacements.push({ row, col, tile: state.draggedTile });
                state.draggedTile = null;
                render();
              }
            };

            if (tile) {
              // Check if this tile is part of the last move and should be highlighted
              const isLastMove = !currentPlayerHasActed && 
                                state.gameState.lastMove && 
                                state.gameState.lastMove.tiles && 
                                state.gameState.lastMove.tiles.includes(key);
              
              cell.appendChild(renderTile(tile, { lastMove: isLastMove }));
            }
            if (pending) {
              const pendingTile = renderTile(pending.tile, {
                onClick: () => {
                  state.pendingPlacements = state.pendingPlacements.filter(p => p !== pending);
                  render();
                }
              });
              pendingTile.style.opacity = '0.8';
              cell.appendChild(pendingTile);
            }
            
            rowDiv.appendChild(cell);
          }
          boardDiv.appendChild(rowDiv);
        }
        console.log('Board created');

        console.log('Creating hand with', currentPlayer.hand ? currentPlayer.hand.length : 0, 'tiles');
        const handDiv = document.getElementById('hand');
        if (!handDiv) {
          console.error('Hand div not found!');
          return;
        }
        if (currentPlayer.hand && Array.isArray(currentPlayer.hand)) {
          currentPlayer.hand.forEach(tile => {
            const isSelectedForSwap = state.selectedTiles.find(t => t.id === tile.id);
            const isSelectedForPlacement = state.tileToPlace && state.tileToPlace.id === tile.id;
            const isAlreadyPlaced = state.pendingPlacements.find(p => p.tile.id === tile.id);
            
            if (isAlreadyPlaced) return; // Don't show tiles that are already placed
            
            const tileEl = renderTile(tile, {
              draggable: true,
              selected: isSelectedForSwap,
              onDragStart: () => { state.draggedTile = tile; },
              onClick: () => {
                if (!isMyTurn) return;
                
                // If clicking the tile that's selected for placement, deselect it
                if (isSelectedForPlacement) {
                  state.tileToPlace = null;
                  render();
                  return;
                }
                
                // If clicking a tile that's selected for swap, deselect it
                if (isSelectedForSwap) {
                  state.selectedTiles = state.selectedTiles.filter(t => t.id !== tile.id);
                  // If we now have exactly 1 tile selected, make it placement mode
                  if (state.selectedTiles.length === 1) {
                    state.tileToPlace = state.selectedTiles[0];
                    state.selectedTiles = [];
                  }
                  render();
                  return;
                }
                
                // If we already have tiles selected for swap, add this one too
                if (state.selectedTiles.length > 0) {
                  state.selectedTiles.push(tile);
                  render();
                  return;
                }
                
                // If we have a placement tile selected, switch to multi-select (swap mode)
                if (state.tileToPlace) {
                  state.selectedTiles = [state.tileToPlace, tile];
                  state.tileToPlace = null;
                  render();
                  return;
                }
                
                // Otherwise, select this tile for placement
                state.tileToPlace = tile;
                render();
              }
            });
            
            // Highlight tile selected for placement (green)
            if (isSelectedForPlacement) {
              tileEl.style.border = '3px solid #27ae60';
              tileEl.style.boxShadow = '0 0 10px rgba(39, 174, 96, 0.5)';
            }
            
            // Highlight tiles selected for swap (red)
            if (isSelectedForSwap) {
              tileEl.style.border = '3px solid #e74c3c';
            }
            
            handDiv.appendChild(tileEl);
          });
        }
        console.log('Hand populated');

        if (isMyTurn && state.gameState.status === 'playing') {
          const playBtn = document.getElementById('playBtn');
          const cancelBtn = document.getElementById('cancelBtn');
          const swapBtn = document.getElementById('swapBtn');
          if (playBtn) playBtn.onclick = playTiles;
          if (cancelBtn) cancelBtn.onclick = () => { 
            state.pendingPlacements = []; 
            state.tileToPlace = null;
            render(); 
          };
          if (swapBtn) swapBtn.onclick = swapTiles;
        }
      }
    }

    // Wait for scripts to load, then render
    window.addEventListener('load', () => {
      console.log('Window loaded, rendering menu');
      setTimeout(() => {
        render();
      }, 100);
    });
  </script>
</body>
</html>
